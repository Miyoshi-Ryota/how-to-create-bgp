:toc:
:source-highlighter: pygments
:prewrap!:


= 作って学ぶルーティングプロトコル〜RustでBGPを実装〜
Miyoshi Ryota (@llp_qlv / mr-csce (miyoshi))

== はじめに
現在執筆中です。
なお本書の一部はChrome / Firefoxでしか動作しません。
Safari / IE / Edgeでは動作しません。

次の本書のGitHubリポジトリや、本書で作成したBGPデーモンのリポジトリにStarをいただけると嬉しいです。
++++
本書のリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=how-to-create-bgp
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
本書で作成したBGPデーモンのリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=mrbgpdv2
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
++++

本書ではルーティングプロトコルの1つであるBGP（特に今回はEBGP4）をRustで実装する本です。
読者に以下の前提知識を求めています。

. ルーティングプロトコルは聞いたことがある。
. スタティックルートとは何か分かる。
. ルーティングテーブルを見て意味が分かる。
. 何らかのプログラミング言語でのプログラミング経験

以下の経験があるとよりわかりやすいかもしれません。

. BGPの運用経験

=== 執筆環境
筆者は以下の環境で作成・動作確認しています。

* Ubuntu 20.04 LTS / Pop!_OS 20.04 LTS
* cargo 1.53.0-nightly (f3e13226d 2021-04-30)
* rustc 1.54.0-nightly (676ee1472 2021-05-06)

おそらくほとんど全てのLinux Distribution、MacOSでも動作するものと考えていますが、確認・テストはしていません。
RustのVersionについても同様にテストしていませんが、
ある程度新しければ動作すると考えています。

== BGPの実装に必要な知識の学習
=== BGPとは
本章は執筆予定です。すでに良い教材が多く存在するため後回しにしています。
本章が執筆されるまでの参考文献として、2つ紹介します。
BGPについて詳しくない方は、どちらかを読み、本章以降に進んでください。
すべての内容を記憶する必要はありません。
なんとなく見ておくと、本章以降の理解が容易になります。

https://www.infraexpert.com/study/study60.html[ネットワークエンジニアとして - BGPの技術]の次の章が参考になります。

* https://www.infraexpert.com/study/bgpz01.html[BGP（ Border Gateway Protocol ）とは]
* https://www.infraexpert.com/study/bgpz02.html[BGP - 4つのメッセージ、6つのステータスと状態遷移]
* https://www.infraexpert.com/study/bgpz03.html[BGP - IBGPとEBGPの違い]
* https://www.infraexpert.com/study/bgpz04.html[BGP - スタブAS、トランジットAS、非トランジットAS]
* https://www.infraexpert.com/study/bgpz05.html[BGP - パスアトリビュート（ パス属性 ）＆ ベストパス選択]
* https://www.infraexpert.com/study/bgpz06.html[BGP - コンフィグ設定 - 基本設定]

http://www5e.biglobe.ne.jp/aji/30min/index.html[30分間ネットワーキング]の次の章が参考になります。

* http://www5e.biglobe.ne.jp/aji/30min/16.html[第16回 BGP4(1) AS]
* http://www5e.biglobe.ne.jp/aji/30min/17.html[第17回 BGP4(2) BGPピア]
* http://www5e.biglobe.ne.jp/aji/30min/18.html[第18回 BGP4(3) IBGPとEBGP]
* http://www5e.biglobe.ne.jp/aji/30min/19.html[第19回 BGP4(4) パスアトリビュート]
* http://www5e.biglobe.ne.jp/aji/30min/20.html[第20回 BGP4(5) ベストパス選択]

=== BGPはイベント駆動ステートマシン
=== イベント駆動ステートマシンとは [[what_is_event_driven_state_machine]]
イベント駆動ステートマシンとは、現在の状態（ステート）と入力（イベント）によって動作が決定するモノのモデルです。

例として、テレビをステートマシンとして表現します。
テレビの状態として、1. 電源ON、2. 電源OFFの2状態が存在し、入力としてa. 電源ボタンの押下、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下の3つが存在するとします。本来のテレビはもっと多数の状態やイベントを持っていますが、ここでは例示のためにシンプルにしています。

テレビの状態が1. 電源OFFのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源ONに遷移します。テレビの状態が1. 電源OFFのときに、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合はテレビの状態は1. 電源OFFのままで何も起こりません。

テレビの状態が2. 電源ONのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源OFFに遷移します。テレビの状態が2. 電源ONのときb. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合は、テレビの状態は2. 電源ONのまま音量が増減します。

このように現在の状態と、入力によって動作が決定するモノとして表現することが可能です。これを図示すると<<example_state_machine_diagram>>になります。

[[example_state_machine_diagram]]
[plantuml,title=テレビのステートマシン図]
----
@startuml

state 電源OFF

state 電源ON

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----

本書ではステートマシン図では表しにくい動作の内容について、<<example_state_machine_diagram_2>>のように付箋をつけることにします。
この図では、状態が電源ONのときに、音量増加ボタンの押下が入力されたときには、状態を電源ONのままにするだけでなく、音量を増加させることを表しています。

[[example_state_machine_diagram_2]]
[plantuml,title=テレビのイベント駆動ステートマシンとしての表現（本書の記法）]
----
@startuml

state 電源OFF

state 電源ON

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
note on link
   音量の増加
end note
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----

=== イベント駆動ステートマシンの例[[example_of_event_driven_state_machine]]
イベント駆動ステートマシンをどのよう実装すればいいのかという勘所を掴んでもらうために<<what_is_event_driven_state_machine>>の章で例示したテレビをコードにします。
次のようになります。

[[example_of_state_machine_impl]]
[source,rust,linenums,title="イベント駆動ステートマシンの例（テレビ）"]
----
use rand::Rng;
use std::collections::VecDeque;
use std::thread;
use std::time::Duration;

#[derive(Debug)]
enum State {
    PowerOn,
    PowerOff,
}

#[derive(Debug)]
enum Event {
    PushedPowerButton,
    PushedVolumeIncreaseButton,
    PushedVolumeDecreaseButton,
}

struct TV {
    now_state: State,
    event_queue: EventQueue,
    volume: u8,
}

impl TV {
    pub fn new() -> Self {
        let now_state = State::PowerOff;
        let event_queue = EventQueue::new();
        let volume = 10;
        Self {
            now_state,
            event_queue,
            volume,
        }
    }

    pub fn be_pushed_power_button(&mut self) {
        self.event_queue.enqueue(Event::PushedPowerButton);
    }

    pub fn be_pushed_volume_increase_button(&mut self) {
        self.event_queue.enqueue(Event::PushedVolumeIncreaseButton);
    }

    pub fn be_pushed_volume_decrease_button(&mut self) {
        self.event_queue.enqueue(Event::PushedVolumeDecreaseButton);
    }

    pub fn handle_event(&mut self, event: Event) {
        match &self.now_state {
            &State::PowerOn => match event {
                Event::PushedPowerButton => {
                    self.now_state = State::PowerOff;
                }
                Event::PushedVolumeIncreaseButton => {
                    self.volume += 1;
                }
                Event::PushedVolumeDecreaseButton => {
                    self.volume -= 1;
                }
            },
            &State::PowerOff => match event {
                Event::PushedPowerButton => {
                    self.now_state = State::PowerOn;
                }
                _ => (),
            },
        }
    }
}

struct EventQueue(VecDeque<Event>);

impl EventQueue {
    pub fn new() -> Self {
        let d = VecDeque::new();
        EventQueue(d)
    }

    pub fn dequeue(&mut self) -> Option<Event> {
        self.0.pop_front()
    }

    pub fn enqueue(&mut self, event: Event) {
        self.0.push_back(event);
    }
}

fn push_random_button_of_tv(tv: &mut TV) {
    let mut rng = rand::thread_rng();
    match rng.gen_range(0..4) {
        1 => tv.be_pushed_power_button(),
        2 => tv.be_pushed_volume_increase_button(),
        3 => tv.be_pushed_volume_decrease_button(),
        _ => (),
    };
}

fn main() {
    let mut tv = TV::new();
    tv.be_pushed_power_button();
    loop {
        push_random_button_of_tv(&mut tv);
        if let Some(event) = tv.event_queue.dequeue() {
            println!(
                "tv information: {{ now_state={:?}, volume={} }}\ninput_event: {:?}",
                tv.now_state, tv.volume, event
            );
            tv.handle_event(event);
        }
        thread::sleep(Duration::from_secs(2));
    }
}
----

103行目でTVのランダムなボタンを押下し、TVにイベント（入力）を送信しています。送信されたEventはイベントキュー、tv.event_queueにエンキューします。
104でイベントキューに保存されているイベント（入力）を取り出します。
TVの現在の状態（State）はTVのインスタンスに保存されています。
109行目でイベント（入力）を扱います。
49行目〜69行目を見ると分かるように、`tv.handle_event(event)`はeventとtvインスタンスに保存されている現在の状態に応じて、動作し次の状態を決定します。
それはイベント駆動ステートマシン、そのものでした。このようにしてイベント駆動ステートマシンを実装することができました。

次が<<log_of_sample_state_machine>>です。

ログの4行目を見ると、電源OFFの状態であることがわかります。
次にログの5行目を見ると、電源ボタンが押されたことがわかります。
次にログの6行目を見ると、電源ONの状態に遷移したことがわかります。
次にログの7行目を見ると、音量増加ボタンが押されたことがわかります。
次にログの8行目を見ると、電源ON状態のまま、音量が11に増加していることがわかります。

一方でログの16、17、18行目を見ると、電源OFF状態のときに音量増加ボタンが押されても、電源OFF状態のままで音量の変動もないことがわかります。

[[log_of_sample_state_machine]]
[source,html,linenums,title="実行時のログ"]
----
mrcsce@pop-os:~/programming/rustProjects/samplecode$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/samplecode`
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeIncreaseButton
^C
mrcsce@pop-os:~/programming/rustProjects/samplecode$
----


これは<<what_is_event_driven_state_machine>>の章で例示した通りの動作です。
例示したイベント駆動ステートマシンを実装できていることが確かめられました。
BGPのステートマシンも前述の<<example_of_state_machine_impl>>に似た方針で実装していきます。

=== BGPはどんなイベント駆動ステートマシンなのか
BGPはどのようなイベント駆動ステートマシンとして表すのが良いでしょうか。

実は https://tools.ietf.org/html/rfc4271[RFC4271-A Border Gateway Protocol 4 (BGP-4)]の https://tools.ietf.org/html/rfc4271#section-8[8.  BGP Finite State Machine (FSM)]に、イベント駆動ステートマシンの定義の記載があります。

しかし最初から https://tools.ietf.org/html/rfc4271#section-8[8.  BGP Finite State Machine (FSM)]を参照して、完全なBGPを作成することは大変です。
そのため本書ではBGPを次の段階に分けて開発します。

1. まずは1つのピアがEstablishedに遷移可能
2. 1つのピアでUpdate Messageの交換やUpdate Messageの内容にしたがってRouting Tableへの書き込みが可能
3. 複数のピアを扱うことが可能
4. 細かい完成度を増加

本章のコードは GitHubの https://github.com/Miyoshi-Ryota/mrbgpdv2[本書のリポジトリ]にすべて公開しています。
本書中にすべてのコードを乗せるつもりですが、断片のコードではなくすべてのコードを一気に閲覧したい方はリポジトリを参照してください。
また本章の第一段階「<<first_rev>>」のコードは同リポジトリの https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/main/mrbgpdv2first[同リポジトリのmrbgpdv2first/] に存在します。


== 1つのピアがEstablishedに遷移するところまでの実装 [[first_rev]]
まずは1つのピアがEstablishedに至るまでの正常系のみのイベント駆動ステートマシンを実装します。

RFCの方針の通り、1つのBGPピアを1つのイベント駆動ステートマシンとして表します。
BGPのイベント駆動ステートマシンの状態もIdle, Connect, OpenConfirm, OpenSent, Establishedの5つ用意します。
この状態は、 https://www.infraexpert.com/study/bgpz02.html[BGP - 4つのメッセージ、6つのステータスと状態遷移] で説明しているBGPの6つの状態のうちActiveを除いたものと対応しています。Activeは非正常系パスでしか遷移しない状態のため、第一段階では除いています。

第一段階のイベントとして次の5個を使用します。イベントの名前と定義はRFCにしたがってしています。

[cols=2*, title=BGPのイベント駆動ステートマシンのイベント]
|===
| イベント名 | 定義
| ManualStart | システムの管理者が手動でピアのコネクションをスタートさせた際のイベント
| Tcp_CR_Acked| TCPコネクションのリクエストを確立させた際のイベント。言い換えれば、システムがTCP SYNを送信し、TCP SYN/ACKを受信し、TCP ACKを送信したときのイベント。
| TcpConnectionConfirmed | TCPコネクションが確立された際のイベント。言い換えれば、対向先からTCP SYNを受け取り、システムがTCP SYN/ACKを送信し、TCP ACKを受信したときのイベント
| BGPOpen | 正常なOpen Messageを受信したときのイベント
| KeepAliveMsg | Keepalive Messageを受信したときのイベント
|===


以下に<<first_impl_bgp>>を図示します。図中の黒丸はステートマシンの初期状態を表しています。図示していない（想定していない）遷移が発生した場合はすべてクラッシュすることにします。例えば、Connect状態で、BGP Open eventが発生した場合はクラッシュすることにします。

[[first_impl_bgp]]
[plantuml,title="第一段階で実装するステートマシン"]
----
@startuml

state Idle
state Connect
state OpenConfirm
state OpenSent
state Established

[*] --> Idle
Idle --> Connect : ManualStart event
note on link
   対向側機器とTCPコネクションを作成を試みる。
end note
Connect --> OpenSent : Tcp_CR_Acked | TcpConnectionConfirmed event
note on link
   対向側機器にBGP OpenMessageを送信する。
end note
OpenSent --> OpenConfirm : BGPOpen event
note on link
    対向機器にBGP Keepalive Messageを送信する。
end note
OpenConfirm --> Established : KeepAliveMsg event

@enduml
----

=== 作業の明確化
ここまででなんとなく作るものが見えてきたでしょうか。本章では、<<first_rev>>をToDoレベルに明確化します。

[title=タスクリスト]
* [ ] プロジェクトを作成する
* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


=== プロジェクトの作成

Rustは以下のコマンドで新しいプロジェクトを作成することが出来ます。
[source]
----
cargo new <プロジェクトの名前>
----

[title=タスクリスト]
* [x] プロジェクトを作成する
* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


=== Connect Stateに遷移する
それでは中身に入っていきましょう。
下記に取り組みます。

* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる

BGPは1つのピアが1つのイベント駆動ステートマシンとして表せます。
ピアに関するソースコードは./src/bgp/peer.rsに書くことにしましょう。

 ./src/bgp/peer.rsを追加するとディレクトリ構造は下記のようになります。

[source]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── bgp
│   │   ├── mod.rs
│   │   └── peer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title="./lib.rs]
----
pub mod bgp;
----

[source,rust,linenums,title="./bgp/mod.rs]
----
pub mod peer;
----

[source,rust,linenums,title="./bgp/peer.rs]
----
// 空ファイルです
----

まずテストを書きましょう。
Connectに遷移するまでの過程は<<bgp_first_test, 次>>のようにしてみましょう。

[[bgp_first_test]]
[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/connect-state-made/mrbgpdv2first/src/bgp/peer.rs[lines=58..69]
----

bgp_peer.start()でピアのコネクションを開始（ManualStartイベントを発火）させ、bgp_peer.next_step()で、そのピアのイベントキューからイベントを1つ取り出しハンドリングするつもりのコードです。

実はConnect Stateに遷移するところまででは、Configは不要です。しかしこの後、すぐに使用するので、この段階で合わせて実装しています。


このテストが通るまでコンパイラのエラーにしたがってコードを追加していくと下記のようになります。

このコードは、<<example_of_event_driven_state_machine>>で示した例とほとんど一致しています。Peer構造体がステートマシンです。

[source,title="ディレクトリ構造"]
----
├── src
│   ├── bgp
│   │   ├── config.rs
│   │   ├── event_queue.rs
│   │   ├── mod.rs
│   │   └── peer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title="src/bgp/mod.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/mod.rs[]
----


[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/peer.rs[]
----

[source,rust,linenums,title="src/bgp/event_queue.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/event_queue.rs[]
----

[source,rust,linenums,title="src/bgp/config.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/config.rs[]
----


それではテストを実行し、OKになることを確認しましょう。
[source]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cargo test
   Compiling mrbgpdv2first v0.1.0 (/home/mrcsce/programming/rustProjects/mrbgpdv2/mrbgpdv2first)
    Finished test [unoptimized + debuginfo] target(s) in 0.48s
     Running unittests (target/debug/deps/mrbgpdv2first-773462fadd3e9533)

running 1 tests
test bgp::peer::tests::peer_can_transition_to_connect_start ... ok
----

これでまた1つタスクが完了しました。

[title=タスクリスト]
* [x] プロジェクトを作成する
* [x] Connect Stateに遷移する
    - [x] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


=== OpenSent Stateに遷移する
次に下記に取り組みます。

* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する

まずはテストを書きます。
threadを使用して擬似的にリモート側のコンピュータを表しています。

[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/peer.rs[lines=90..91;93..94;105..128]
----

このテストが通れば、上記のタスクは完了したと言えます。
以下のようなコードの更新でテストを通すことが可能です。

GitHub上で差分を確認したい場合は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/compare/4028dd5957849b2ed4b3d7432f56667125163f92...f133fc092a43103322ceadb4b40d9d9f28952548[GitHub上での差分]を閲覧ください。

差分の内容を解説します。差分は大きく分けて3つあります。

* Peerにcreate_tc_connection_to_remote_ipメソッドを追加しました。このメソッドは現在のモードに合わせてTCPコネクションを作成します。TCPコネクションの作成に成功した場合、その旨を表すイベントEvent::TcpCrAcked / Event::TcpConnectionConfirmedをピアのイベントキュー、Peer.event_queue、にエンキューします。
* Idle状態でManualStart Eventが発生した時にTCPコネクションの作成を試みるようにしました。これは、<<first_impl_bgp>>で示した通りです。具体的にはhandle_eventメソッドにて、create_tcp_connection_to_remote_ipメソッドを呼び出しています。
* Peerのhandle_eventメソッドでState::Connectの時にEvent::TcpCrAcked / Event::TcpConnectionConfirmedを扱えるようにしました。<<first_impl_bgp>>で示した通り、State::Connectの時にEvent::TcpCrAcked / Event::TcpConnectionConfirmedが発生した場合、OpenSentステートに遷移します。BGPOpenMessageの送信は次の章で行いますので、この段階ではOpenSentステートに遷移するところまでを行っています。

[source,rust,linenums,title=src/bgp/config.rs]
----
 use std::{net::Ipv4Addr, str::FromStr};
 pub struct Config {
     local_as_number: bgp::AutonomousSystemNumber,
-    local_ip_address: Ipv4Addr,
+    pub local_ip_address: Ipv4Addr,
     remote_as_number: bgp::AutonomousSystemNumber,
-    remote_ip_address: Ipv4Addr,
-    mode: Mode,
+    pub remote_ip_address: Ipv4Addr,
+    pub mode: Mode,
 }

-enum Mode {
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum Mode {
     Passive,
     Active,
 }

 #[derive(Debug)]
-struct ModeParseError;
+pub struct ModeParseError;

 impl FromStr for Mode {
     type Err = ModeParseError;
----

[source,rust,linenums,title=src/bgp/peer.rs]
----
 use super::event_queue::EventQueue;
 use crate::bgp::config::Config;
+use crate::bgp::config::Mode;
+use std::net::{TcpListener, TcpStream};

 struct Peer {
     config: Config,
     event_queue: EventQueue,
     now_state: State,
+    tcp_connection: Option<TcpStream>,
 }

 impl Peer {
     pub fn new(config: Config) -> Self {
         let event_queue = EventQueue::new();
         let now_state = State::Idle;
+        let tcp_connection = None;
         Self {
             config,
             event_queue,
             now_state,
+            tcp_connection,
         }
     }

         }
     }

+    fn create_tcp_connection_to_remote_ip(&mut self) -> Option<TcpStream> {
+        let remote_addr = self.config.remote_ip_address;
+        let bgp_port = 179;
+        if self.config.mode == Mode::Active {
+            let tcp_connection = TcpStream::connect((remote_addr, bgp_port)).ok();
+            if tcp_connection.is_some() {
+                self.event_queue.enqueue(Event::TcpCrAcked);
+            };
+            tcp_connection
+        } else {
+            let tcp_listener = TcpListener::bind((self.config.local_ip_address, bgp_port))
+                .expect("port 179にbind出来ません。");
+            let tcp_connection = tcp_listener.accept().map(|v| v.0).ok();
+            if tcp_connection.is_some() {
+                self.event_queue.enqueue(Event::TcpConnectionConfirmed);
+            };
+            tcp_connection
+        }
+    }
+
     fn handle_event(&mut self, event: Event) {
         match self.now_state {
             State::Idle => match event {
                 Event::ManualStart => {
+                    self.tcp_connection = self.create_tcp_connection_to_remote_ip();
                     self.now_state = State::Connect;
                 }
                 _ => {}
             },
-            _ => (),
+            State::Connect => match event {
+                Event::TcpConnectionConfirmed | Event::TcpCrAcked => {
+                    self.now_state = State::OpenSent;
+                }
+                _ => {}
+            },
+            _ => {}
         }
     }
 }
 #[cfg(test)]
 mod tests {
     use super::*;
+    use std::thread;
+    use std::time;
+
     #[test]
     fn peer_can_transition_to_connect_start() {
         let config: Config = "64512 127.0.0.1 64513 127.0.0.2 active".parse().unwrap();
         bgp_peer.next_step();
         assert_eq!(bgp_peer.now_state, State::Connect);
     }
+
+    #[test]
+    fn peer_can_transition_to_open_sent_start() {
+        let _remote_bgp = thread::spawn(|| {
+            let remote_config: Config = "64513 127.0.0.2 64512 127.0.0.1 passive".parse().unwrap();
+            let mut remote_bgp_peer = Peer::new(remote_config);
+            remote_bgp_peer.start();
+            remote_bgp_peer.next_step();
+            remote_bgp_peer.next_step();
+            assert_eq!(remote_bgp_peer.now_state, State::OpenSent);
+        });
+
+        // 先にPassiveモード側の処理が進むことを保証する。
+        thread::sleep(time::Duration::from_secs_f32(0.5));
+
+        let local_config: Config = "64512 127.0.0.1 64513 127.0.0.2 active".parse().unwrap();
+        let mut local_bgp_peer = Peer::new(local_config);
+
+        local_bgp_peer.start();
+        local_bgp_peer.next_step();
+        local_bgp_peer.next_step();
+
+        assert_eq!(local_bgp_peer.now_state, State::OpenSent);
+    }
 }
----

なおMacを使用している場合は、127.0.0.2がループバックIPとして設定されていません。Macを使用している場合はテストを実行可能にするために下記コマンドを実行してください。
----
sudo ifconfig lo0 alias 127.0.0.2
----

本コードでは`create_tcp_connection_to_remote_ip`メソッドでバインドしています。
これはroot権限が必要な操作です。
root権限でテストを実行可能にする必要があります。
cargoのコンフィグファイルにrunner = 'sudo -E'と指定することで
root権限でテストを実行してくれます。

[source,title=~/.cargo/config]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cat ~/.cargo/config 

# nightly-x86_64-unknown-linux-gnu
[target.x86_64-unknown-linux-gnu]
runner = 'sudo -E'
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ 
----


テストを走らせてみましょう。
下記が結果です。無事にテストが通っていることが確認できました。
[source, title=テスト結果]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cargo test 
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests (target/debug/deps/mrbgpdv2first-773462fadd3e9533)

running 2 tests
test bgp::peer::tests::peer_can_transition_to_connect_start ... ok
test bgp::peer::tests::peer_can_transition_to_open_sent_start ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.50s

     Running unittests (target/debug/deps/mrbgpdv2first-eb97df666ba678c7)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests mrbgpdv2first

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ 
----

これで、またタスクが一つ完了しました。

* [x] プロジェクトを作成する
* [x] Connect Stateに遷移する
    - [x] ManualStart Eventを発生させる
* [x] OpenSent Stateに遷移する
    - [x] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


現段階の全体のコードを記載します。GitHub上で閲覧したい方は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first[GitHub-現段階の全体のコード]を参照してください。

[source,rust,linenums,title="src/bgp/mod.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/mod.rs[]
----


[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/peer.rs[]
----

[source,rust,linenums,title="src/bgp/event_queue.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/event_queue.rs[]
----

[source,rust,linenums,title="src/bgp/config.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/config.rs[]
----


=== OpenConfirm Stateに遷移する
次は下記に取り組みましょう。

* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する

まず、テストを書きます。
ここからは通信が発生するため、正確に何度.next_step()を呼んだときにお目当ての状態に遷移するのかわかりません。
そのため、50回以内に想定のステータスに遷移することでテストOKとしています。
また複数のテストケースで同じソケットアドレスにbindします。複数のテストが同時に動き、同時に複数回同じソケットアドレスにbindすることを防ぐために、テストは1つづつ実行することとします。また、ここからは少しずつ複雑になるためロガーも仕込んでいます。
そのためテストを走らせるときは次のようなコマンドを使用します。

----
RUST_LOG=info cargo test -- --nocapture --test-threads=1
----

[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/peer.rs[lines=198..201;237..274]
----

このテストが通れば、上記のタスクは完了したと言えます。

以下のようなコードの更新でテストを通すことが可能です。
差分をGitHubで閲覧したい方は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/compare/f133fc092a43103322ceadb4b40d9d9f28952548...87771a19f2f90e16546a4603a235cb9f02b4313d[GitHub上の差分]を閲覧してください。

差分を解説します。この差分ではOpenMessageの送信と受信の2つを行っています。

OpenMessageを送信する部分について説明します。

* PeerにBGP Messageを送信するメソッド、send_bgp_message_to_remote_peer、を追加しました。
* Peerのhandle_eventメソッド内で、send_bgp_message_to_remote_peerメソッドを使用して、OpenMessageの送信を行うようにしました。
* BGPMessageやOpenMessageを表す構造体をsrc/bgp/message.rs配下に追加しました。これらの構造体はserializeメソッドでデータとして送信可能なバイト列に変換し、deserialize関連関数でバイト列から構造体に変換することにしました。Enumとして実装しているBgpMessageはTraitとして実装しても良かったのですが、受信時に動的ディスパッチが必要になったため、ここではシンプルにEnumとしています。
* BgpOpenMessageの構造については、RFCで定義されている内容をシンプルに構造体にしました。 https://datatracker.ietf.org/doc/html/rfc4271#section-4.1[RFC4271 Section4.1 Message Header Format]、 https://datatracker.ietf.org/doc/html/rfc4271#section-4.1[RFC4271 Section4.2 OPEN Message Format] に定義されています。BGPにはタイマーイベントがあります。タイマーイベントとは、状態XになってY秒後に発生するといったイベントです。HoldTimeは、タイマーイベントの管理に使用します。タイマーイベントのほとんどはエラー処理なので、現段階では実装しません。しかし他社実装から受信したパケットにはHoldTimeの情報が含まれています。HoldTimeを含むパケットを送受信するために、現段階で構造体にはHoldTimeを含んでいます。

OpenMessageを受信する部分について説明します。
ToDo：説明する

* non_blocking modeに変更していること
* next_stepにrecive_one_message()を入れていること
* handle_bgp_messageでハンドルしてイベントを注入していること
* recieve_one_messageの説明
    * transfer_data_tcp-connection_to_self_bufferは、該当のコネクションで受信したデータをすべてself.bufferに移している
    * retrive_one_message_from_bufferはself.bufferから1つのBGPメッセージのバイト列を取得している。
    * そのバイト列をモデルに変換している

[[bgp_header_structure]]
[packetdiag]
----
{
  colwidth = 16
  node_height = 72

  0-15: Marker
  16-17: Length
  18: Type
}
----

[[bgp_open_message_structure]]
[packetdiag]
----
{
  colwidth = 16
  node_height = 72
  
  0: Version
  1-2: My Autonomous System
  3-4: HoldTime
  5-8: BGP Identifier
  9: Opt Parm Len
  10-31: Optional Parameters (variable)
}
----

[source,rust,linenums,title=Cargo.toml]
----
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
+log = "0.4.0"
+ env_logger = "0.8.3"
----

[source,rust,linenums,title=src/bgp/config.rs]
----
 use crate::bgp;
 use std::{net::Ipv4Addr, str::FromStr};
 pub struct Config {
-    local_as_number: bgp::AutonomousSystemNumber,
+    pub local_as_number: bgp::AutonomousSystemNumber,
     pub local_ip_address: Ipv4Addr,
     remote_as_number: bgp::AutonomousSystemNumber,
     pub remote_ip_address: Ipv4Addr,
deleted file mode 100644
+++ /dev/null
-use crate::bgp::peer::Event;
-use std::collections::VecDeque;
-
-pub struct EventQueue(VecDeque<Event>);
-
-impl EventQueue {
-    pub fn new() -> Self {
-        EventQueue(VecDeque::new())
-    }
-
-    pub fn enqueue(&mut self, event: Event) {
-        self.0.push_front(event);
-    }
-
-    pub fn dequeue(&mut self) -> Option<Event> {
-        self.0.pop_back()
-    }
-}
----

[source,rust,linenums,title=src/bgp/message.rs]
----
+use super::timer::HoldTime;
+use super::AutonomousSystemNumber;
+use std::{convert::TryInto, net::Ipv4Addr};
+
+#[derive(Debug)]
+pub enum BgpMessage {
+    Open(BgpOpenMessage),
+}
+impl BgpMessage {
+    pub fn serialize(&self) -> Vec<u8> {
+        match self {
+            BgpMessage::Open(open) => open.serialize(),
+            _ => panic!(),
+        }
+    }
+
+    pub fn deserialize(bytes: &Vec<u8>) -> Self {
+        let bgp_type = BgpMessageType::from_type_number(bytes[18]);
+        match bgp_type {
+            BgpMessageType::Open => BgpMessage::Open(BgpOpenMessage::deserialize(bytes)),
+        }
+    }
+
+    pub fn get_type(&self) -> BgpMessageType {
+        match self {
+            BgpMessage::Open(_) => BgpMessageType::Open,
+        }
+    }
+}
+
+#[derive(Debug)]
+pub struct BgpMessageHeader {
+    pub length: u16,
+    pub type_: BgpMessageType,
+}
+
+impl BgpMessageHeader {
+    fn serialize(&self) -> Vec<u8> {
+        let marker = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
+        let length = self.length.to_be_bytes();
+        let type_ = self.type_.to_type_number();
+        let mut bytes = vec![];
+        bytes.append(&mut marker.to_vec());
+        bytes.append(&mut length.to_vec());
+        bytes.push(type_);
+        bytes
+    }
+
+    pub fn deserialize(bytes: &Vec<u8>) -> Self {
+        let length = u16::from_be_bytes(bytes[16..18].try_into().unwrap());
+        let type_ = BgpMessageType::from_type_number(bytes[18]);
+        Self { length, type_ }
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+pub enum BgpMessageType {
+    Open,
+}
+
+impl BgpMessageType {
+    fn to_type_number(&self) -> u8 {
+        match self {
+            BgpMessageType::Open => 1,
+        }
+    }
+
+    fn from_type_number(type_number: u8) -> Self {
+        match type_number {
+            1 => BgpMessageType::Open,
+            _ => panic!(),
+        }
+    }
+}
+
+#[derive(Debug)]
+struct BgpVersion(u8);
+
+#[derive(Debug)]
+pub struct BgpOpenMessage {
+    header: BgpMessageHeader,
+    version: BgpVersion,
+    my_autonomous_system_number: AutonomousSystemNumber,
+    hold_time: HoldTime,
+    bgp_identifier: Ipv4Addr,
+    optional_parameter_length: u8,
+    // optional_parameterは実装・使用しないが、
+    // 相手から受信したときに一応保存しておくためにプロパティとして用意している。
+    optional_parameters: Vec<u8>,
+}
+
+impl BgpOpenMessage {
+    pub fn new(my_as_number: AutonomousSystemNumber, my_ip_addr: Ipv4Addr) -> Self {
+        let header = BgpMessageHeader {
+            length: 29,
+            type_: BgpMessageType::Open,
+        };
+        let version = BgpVersion(4);
+        let my_autonomous_system_number = my_as_number;
+        let hold_time = HoldTime(240);
+        let bgp_identifier = my_ip_addr;
+        let optional_parameter_length = 0;
+        let optional_parameters = vec![];
+        Self {
+            header,
+            version,
+            my_autonomous_system_number,
+            hold_time,
+            bgp_identifier,
+            optional_parameter_length,
+            optional_parameters,
+        }
+    }
+}
+
+impl BgpOpenMessage {
+    fn serialize(&self) -> Vec<u8> {
+        let mut bytes = vec![];
+        bytes.append(&mut self.header.serialize());
+        bytes.push(self.version.0);
+        bytes.append(&mut self.my_autonomous_system_number.0.to_be_bytes().to_vec());
+        bytes.append(&mut self.hold_time.0.to_be_bytes().to_vec());
+        bytes.append(&mut self.bgp_identifier.octets().to_vec());
+        bytes.push(self.optional_parameter_length);
+        bytes.append(&mut self.optional_parameters.clone());
+        bytes
+    }
+
+    fn deserialize(bytes: &Vec<u8>) -> Self {
+        let header = BgpMessageHeader::deserialize(&bytes[0..19].to_vec());
+        let version = BgpVersion(bytes[19]);
+        let my_autonomous_system_number =
+            AutonomousSystemNumber(u16::from_be_bytes(bytes[20..22].try_into().unwrap()));
+        let hold_time = HoldTime(u16::from_be_bytes(bytes[22..24].try_into().unwrap()));
+        let bgp_identifier: Ipv4Addr = Ipv4Addr::new(bytes[24], bytes[25], bytes[26], bytes[27]);
+        let optional_parameter_length = bytes[28];
+        let optional_parameters = bytes[29..].to_vec();
+
+        Self {
+            header,
+            version,
+            my_autonomous_system_number,
+            hold_time,
+            bgp_identifier,
+            optional_parameter_length,
+            optional_parameters,
+        }
+    }
+}
----

[source,rust,linenums,title=src/bgp/mod.rs]
----
-mod config;
-mod event_queue;
+pub mod config;
+mod message;
 pub mod peer;
+mod queue;
+mod timer;
 
-struct AutonomousSystemNumber(u16);
+#[derive(Debug, Copy, Clone)]
+pub struct AutonomousSystemNumber(u16);
----

[source,rust,linenums,title=src/bgp/peer.rs]
----
-use super::event_queue::EventQueue;
+use super::{
+    message::BgpOpenMessage,
+    queue::{EventQueue, MessageQueue},
+};
 use crate::bgp::config::Config;
 use crate::bgp::config::Mode;
-use std::net::{TcpListener, TcpStream};
+use crate::bgp::message::{BgpMessage, BgpMessageHeader, BgpMessageType};
+use std::{
+    io::{self, Read, Write},
+    net::{TcpListener, TcpStream},
+};
 
-struct Peer {
+pub struct Peer {
     config: Config,
     event_queue: EventQueue,
+    message_queue: MessageQueue,
     now_state: State,
     tcp_connection: Option<TcpStream>,
+    buffer: Vec<u8>,
 }
 
 impl Peer {
     pub fn new(config: Config) -> Self {
         let event_queue = EventQueue::new();
+        let message_queue = MessageQueue::new();
         let now_state = State::Idle;
         let tcp_connection = None;
+        let buffer = vec![];
         Self {
             config,
             event_queue,
+            message_queue,
             now_state,
             tcp_connection,
+            buffer,
         }
     }
 
     }
 
     pub fn next_step(&mut self) {
+        if let Some(bgp_message) = self.recieve_one_message() {
+            info!("Recive bgp message {:?}", bgp_message);
+            self.handle_bgp_message(bgp_message)
+        }
+
         if let Some(event) = self.event_queue.dequeue() {
+            debug!("Now state {:?}, handling event {:?}", self.now_state, event);
             self.handle_event(event);
         }
     }
 
+    fn transfer_data_tcp_connection_to_self_buffer(&mut self) {
+        let mut buffer = vec![];
+        if self.tcp_connection.is_some() {
+            match self
+                .tcp_connection
+                .as_ref()
+                .unwrap()
+                .read_to_end(&mut buffer)
+            {
+                Ok(_) => (), // Tcp ConnectionがCloseしているときにOk()が返ってくる。
+                Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
+                    self.buffer.append(&mut buffer)
+                }
+                Err(e) => error!("{:?}", e),
+            }
+        }
+    }
+
+    fn handle_bgp_message(&mut self, bgp_message: BgpMessage) {
+        match bgp_message.get_type() {
+            BgpMessageType::Open => {
+                self.event_queue.enqueue(Event::BgpOpen);
+            }
+            _ => {}
+        }
+        self.message_queue.enqueue(bgp_message);
+    }
+
+    fn retrive_one_message_from_buffer(&mut self) -> Option<Vec<u8>> {
+        let minimum_length_of_bgp_message = 19;
+        if self.buffer.len() >= minimum_length_of_bgp_message {
+            let bgp_message_header = BgpMessageHeader::deserialize(&self.buffer[0..19].to_vec());
+            let bgp_message_length: u16 = bgp_message_header.length;
+            let (bgp_message_bytes, buf) = self.buffer.split_at(bgp_message_length as usize);
+            let bgp_message_bytes = bgp_message_bytes.to_vec();
+            self.buffer = buf.to_vec();
+            Some(bgp_message_bytes)
+        } else {
+            None
+        }
+    }
+
+    fn recieve_one_message(&mut self) -> Option<BgpMessage> {
+        self.transfer_data_tcp_connection_to_self_buffer();
+        if let Some(bgp_message_byte) = self.retrive_one_message_from_buffer() {
+            Some(BgpMessage::deserialize(&bgp_message_byte))
+        } else {
+            None
+        }
+    }
+
     fn create_tcp_connection_to_remote_ip(&mut self) -> Option<TcpStream> {
         let remote_addr = self.config.remote_ip_address;
         let bgp_port = 179;
             let tcp_connection = TcpStream::connect((remote_addr, bgp_port)).ok();
             if tcp_connection.is_some() {
                 self.event_queue.enqueue(Event::TcpCrAcked);
+                tcp_connection
+                    .as_ref()
+                    .unwrap()
+                    .set_nonblocking(true)
+                    .unwrap();
             };
             tcp_connection
         } else {
             let tcp_connection = tcp_listener.accept().map(|v| v.0).ok();
             if tcp_connection.is_some() {
                 self.event_queue.enqueue(Event::TcpConnectionConfirmed);
+                tcp_connection
+                    .as_ref()
+                    .unwrap()
+                    .set_nonblocking(true)
+                    .unwrap();
             };
             tcp_connection
         }
     }
 
+    fn send_bgp_message_to_remote_peer(&self, bgp_message: BgpMessage) {
+        self.tcp_connection
+            .as_ref()
+            .unwrap()
+            .write(&bgp_message.serialize()[..])
+            .expect("Failed send open message");
+        info!("Send bgp message {:?}", bgp_message);
+    }
+
     fn handle_event(&mut self, event: Event) {
         match self.now_state {
             State::Idle => match event {
             },
             State::Connect => match event {
                 Event::TcpConnectionConfirmed | Event::TcpCrAcked => {
+                    let open_message = BgpOpenMessage::new(
+                        self.config.local_as_number,
+                        self.config.local_ip_address,
+                    );
+                    self.send_bgp_message_to_remote_peer(BgpMessage::Open(open_message));
                     self.now_state = State::OpenSent;
                 }
                 _ => {}
             },
+            State::OpenSent => match event {
+                Event::BgpOpen => {
+                    self.now_state = State::OpenConfirm;
+                }
+                _ => {}
+            },
             _ => {}
         }
     }
     Idle,
     Connect,
     OpenSent,
+    OpenConfirm,
 }
 
-#[derive(PartialEq, Eq, Clone, Copy)]
+#[derive(Debug, PartialEq, Eq, Clone, Copy)]
 pub enum Event {
     ManualStart,
     TcpCrAcked,
     TcpConnectionConfirmed,
+    BgpOpen,
 }
 
 #[cfg(test)]
     use std::thread;
     use std::time;
 
+    fn init() {
+        let _ = env_logger::builder().is_test(true).try_init();
+    }
+
     #[test]
-    fn peer_can_transition_to_connect_start() {
+    fn peer_can_transition_to_connect() {
+        init();
         let config: Config = "64512 127.0.0.1 64513 127.0.0.2 active".parse().unwrap();
         let mut bgp_peer = Peer::new(config);
         bgp_peer.start();
     }
 
     #[test]
-    fn peer_can_transition_to_open_sent_start() {
+    fn peer_can_transition_to_open_sent() {
+        init();
         let _remote_bgp = thread::spawn(|| {
             let remote_config: Config = "64513 127.0.0.2 64512 127.0.0.1 passive".parse().unwrap();
             let mut remote_bgp_peer = Peer::new(remote_config);
 
         assert_eq!(local_bgp_peer.now_state, State::OpenSent);
     }
+
+    #[test]
+    fn peer_can_transition_to_open_confirm() {
+        init();
+        let _remote_bgp = thread::spawn(|| {
+            let remote_config: Config = "64513 127.0.0.2 64512 127.0.0.1 passive".parse().unwrap();
+            let mut remote_bgp_peer = Peer::new(remote_config);
+            remote_bgp_peer.start();
+
+            let max_steps = 50;
+            for _ in 0..max_steps {
+                remote_bgp_peer.next_step();
+                thread::sleep(time::Duration::from_secs_f32(0.1));
+                if remote_bgp_peer.now_state == State::OpenConfirm {
+                    break;
+                };
+            }
+
+            assert_eq!(remote_bgp_peer.now_state, State::OpenConfirm);
+        });
+
+        // 先にPassiveモード側の処理が進むことを保証する。
+        thread::sleep(time::Duration::from_secs_f32(0.5));
+
+        let local_config: Config = "64512 127.0.0.1 64513 127.0.0.2 active".parse().unwrap();
+        let mut local_bgp_peer = Peer::new(local_config);
+
+        local_bgp_peer.start();
+        let max_steps = 50;
+        for _ in 0..max_steps {
+            local_bgp_peer.next_step();
+            thread::sleep(time::Duration::from_secs_f32(0.1));
+            if local_bgp_peer.now_state == State::OpenConfirm {
+                break;
+            };
+        }
+
+        assert_eq!(local_bgp_peer.now_state, State::OpenConfirm);
+    }
 }
----

[source,rust,linenums,title=src/bgp/queue.rs]
----
+use crate::bgp::message::BgpMessage;
+use crate::bgp::peer::Event;
+use std::collections::VecDeque;
+
+pub struct Queue<T>(VecDeque<T>);
+
+impl<T> Queue<T> {
+    pub fn new() -> Self {
+        Queue(VecDeque::new())
+    }
+
+    pub fn enqueue(&mut self, data: T) {
+        self.0.push_front(data);
+    }
+
+    pub fn dequeue(&mut self) -> Option<T> {
+        self.0.pop_back()
+    }
+}
+
+pub type EventQueue = Queue<Event>;
+pub type MessageQueue = Queue<BgpMessage>;
----

[source,rust,linenums,title=src/bgp/timer.rs]
----
+#[derive(Debug)]
+pub struct HoldTime(pub u16);
----

[source,rust,linenums,title=src/lib.rs]
----
+#[macro_use]
+extern crate log;
+
 pub mod bgp;
----



テストを走らせてみましょう。
下記が結果です。無事にテストが通っていることが確認できました。

----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ RUST_LOG=mrbgpdv2=INFO cargo test -- --nocapture --test-threads=1
   Compiling mrbgpdv2first v0.1.0 (/home/mrcsce/programming/rustProjects/mrbgpdv2/mrbgpdv2first)
running 3 tests
test bgp::peer::tests::peer_can_transition_to_connect ... ok
test bgp::peer::tests::peer_can_transition_to_open_confirm ... [2021-05-12T13:42:37Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-12T13:42:37Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-12T13:42:37Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-12T13:42:37Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
ok
test bgp::peer::tests::peer_can_transition_to_open_sent ... [2021-05-12T13:42:38Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-12T13:42:38Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.30s

     Running unittests (target/debug/deps/mrbgpdv2first-229e56fd8674fb31)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests mrbgpdv2first

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
----

これで、またタスクが一つ完了しました。

* [x] プロジェクトを作成する
* [x] Connect Stateに遷移する
    - [x] ManualStart Eventを発生させる
* [x] OpenSent Stateに遷移する
    - [x] TCPコネクションを作成する
* [x] OpenConfirm Stateに遷移する
    - [x] BGP Open Messageを送信する
    - [x] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


現段階の全体のコードを記載します。GitHub上で閲覧したい方は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first[GitHub-現段階の全体のコード]を参照してください。

----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── bgp
│   │   ├── config.rs
│   │   ├── message.rs
│   │   ├── mod.rs
│   │   ├── peer.rs
│   │   ├── queue.rs
│   │   └── timer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title="src/bgp/config.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/config.rs[]
----

[source,rust,linenums,title="src/bgp/message.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/message.rs[]
----


[source,rust,linenums,title="src/bgp/mod.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/mod.rs[]
----


[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/peer.rs[]
----


[source,rust,linenums,title="src/bgp/queue.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/queue.rs[]
----


[source,rust,linenums,title="src/bgp/timer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/timer.rs[]
----

[source,rust,linenums,title="src/lib.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/lib.rs[]
----

[source,rust,linenums,title="src/main.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/main.rs[]
----

=== Establishedに遷移する
さて、次は下記に取り組みましょう。

* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する


まずはテストを書きます。
ほとんど前回のテストと同じです。

[source,rust,linenums,title=src/bgp/peer.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/bf05651e553aee8172b62fa71b6d1efc1b335b87/mrbgpdv2first/src/bgp/peer.rs[lines=277..314]
----

これは下記のような差分でテストを通すことが出来ます。
差分をGitHubで閲覧したい場合は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/compare/87771a19f2f90e16546a4603a235cb9f02b4313d...803b9cd401f2ac85cdabc16516ee76099bfdcb14[GitHub上での差分]を閲覧してください。


BGP Keepalive Messageは https://datatracker.ietf.org/doc/html/rfc4271#section-4.4[RFC4271 section 4.4]に記載されているように、Peerが疎通可能かどうかを確認するためのもので、ただのBGP Headerからのみ成るパケットです。

コードに関しては、これまでとほとんど同じです。OpenMessageを送る要領でKeepaliveを送ります。

[source,rust,linenums,title=src/bgp/message.rs]
----
 #[derive(Debug)]
 pub enum BgpMessage {
     Open(BgpOpenMessage),
+    Keepalive(BgpKeepaliveMessage),
 }
+
 impl BgpMessage {
     pub fn serialize(&self) -> Vec<u8> {
         match self {
             BgpMessage::Open(open) => open.serialize(),
-            _ => panic!(),
+            BgpMessage::Keepalive(keepalive) => keepalive.serialize(),
         }
     }

         let bgp_type = BgpMessageType::from_type_number(bytes[18]);
         match bgp_type {
             BgpMessageType::Open => BgpMessage::Open(BgpOpenMessage::deserialize(bytes)),
+            BgpMessageType::Keepalive => BgpMessage::Keepalive(BgpKeepaliveMessage::deserialize(bytes)),
         }
     }

     pub fn get_type(&self) -> BgpMessageType {
         match self {
             BgpMessage::Open(_) => BgpMessageType::Open,
+            BgpMessage::Keepalive(_) => BgpMessageType::Keepalive,
         }
     }
 }
 #[derive(Debug, Clone, Copy)]
 pub enum BgpMessageType {
     Open,
+    Keepalive,
 }

 impl BgpMessageType {
     fn to_type_number(&self) -> u8 {
         match self {
             BgpMessageType::Open => 1,
+            BgpMessageType::Keepalive => 4,
         }
     }

     fn from_type_number(type_number: u8) -> Self {
         match type_number {
             1 => BgpMessageType::Open,
+            4 => BgpMessageType::Keepalive,
             _ => panic!(),
         }
     }
         }
     }
 }
+
+#[derive(Debug)]
+pub struct BgpKeepaliveMessage {
+    header: BgpMessageHeader,
+}
+
+impl BgpKeepaliveMessage {
+    pub fn new() -> Self {
+        let header = BgpMessageHeader {
+            length: 19,
+            type_: BgpMessageType::Keepalive,
+        };
+        Self { header }
+    }
+
+    fn serialize(&self) -> Vec<u8> {
+        self.header.serialize()
+    }
+
+    fn deserialize(bytes: &Vec<u8>) -> Self {
+        let header = BgpMessageHeader::deserialize(&bytes[0..19].to_vec());
+        Self { header }
+    }
+}
\ No newline at end of file
----

[source,rust,linenums,title=src/bgp/peer.rs]
----
-use super::{
-    message::BgpOpenMessage,
-    queue::{EventQueue, MessageQueue},
-};
+use super::{message::{BgpKeepaliveMessage, BgpOpenMessage}, queue::{EventQueue, MessageQueue}};
 use crate::bgp::config::Config;
 use crate::bgp::config::Mode;
 use crate::bgp::message::{BgpMessage, BgpMessageHeader, BgpMessageType};
         match bgp_message.get_type() {
             BgpMessageType::Open => {
                 self.event_queue.enqueue(Event::BgpOpen);
-            }
+            },
+            BgpMessageType::Keepalive => {
+                self.event_queue.enqueue(Event::Keepalive);
+            },
             _ => {}
         }
         self.message_queue.enqueue(bgp_message);
             },
             State::OpenSent => match event {
                 Event::BgpOpen => {
+                    let keepalive_message = BgpKeepaliveMessage::new();
+                    self.send_bgp_message_to_remote_peer(BgpMessage::Keepalive(keepalive_message));
                     self.now_state = State::OpenConfirm;
                 }
                 _ => {}
             },
-            _ => {}
+            State::OpenConfirm => match event {
+                Event::Keepalive => {
+                    self.now_state = State::Established;
+                }
+                _ => {},
+            },
+            _ => {},
         }
     }
 }
     Connect,
     OpenSent,
     OpenConfirm,
+    Established,
 }

 #[derive(Debug, PartialEq, Eq, Clone, Copy)]
     TcpCrAcked,
     TcpConnectionConfirmed,
     BgpOpen,
+    Keepalive,
 }

 #[cfg(test)]

         assert_eq!(local_bgp_peer.now_state, State::OpenConfirm);
     }
+
+    #[test]
+    fn peer_can_transition_to_established() {
+        init();
+        let _remote_bgp = thread::spawn(|| {
+            let remote_config: Config = "64513 127.0.0.2 64512 127.0.0.1 passive".parse().unwrap();
+            let mut remote_bgp_peer = Peer::new(remote_config);
+            remote_bgp_peer.start();
+
+            let max_steps = 50;
+            for _ in 0..max_steps {
+                remote_bgp_peer.next_step();
+                thread::sleep(time::Duration::from_secs_f32(0.1));
+                if remote_bgp_peer.now_state == State::Established {
+                    break;
+                };
+            }
+
+            assert_eq!(remote_bgp_peer.now_state, State::Established);
+        });
+
+        // 先にPassiveモード側の処理が進むことを保証する。
+        thread::sleep(time::Duration::from_secs_f32(0.5));
+
+        let local_config: Config = "64512 127.0.0.1 64513 127.0.0.2 active".parse().unwrap();
+        let mut local_bgp_peer = Peer::new(local_config);
+
+        local_bgp_peer.start();
+        let max_steps = 50;
+        for _ in 0..max_steps {
+            local_bgp_peer.next_step();
+            thread::sleep(time::Duration::from_secs_f32(0.1));
+            if local_bgp_peer.now_state == State::Established {
+                break;
+            };
+        }
+
+        assert_eq!(local_bgp_peer.now_state, State::Established);
+    }
 }
----


テストの結果です。
[source]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ RUST_LOG=info cargo test -- --nocapture --test-threads=1
    Finished test [unoptimized + debuginfo] target(s) in 0.79s
     Running unittests (target/debug/deps/mrbgpdv2first-8bf406b4cb3db834)

running 4 tests
test bgp::peer::tests::peer_can_transition_to_connect ... ok
test bgp::peer::tests::peer_can_transition_to_established ... [2021-05-16T14:36:40Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-16T14:36:40Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-16T14:36:40Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-16T14:36:40Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-16T14:36:40Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
[2021-05-16T14:36:40Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
[2021-05-16T14:36:40Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
[2021-05-16T14:36:40Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
ok
test bgp::peer::tests::peer_can_transition_to_open_confirm ... [2021-05-16T14:36:41Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-16T14:36:41Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-16T14:36:41Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-16T14:36:41Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-16T14:36:41Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
[2021-05-16T14:36:41Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
ok
test bgp::peer::tests::peer_can_transition_to_open_sent ... [2021-05-16T14:36:41Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
ok
[2021-05-16T14:36:41Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.20s

     Running unittests (target/debug/deps/mrbgpdv2first-229e56fd8674fb31)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests mrbgpdv2first

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ 

----

テストが通ってることを確認できました。
これで、またタスクが一つ完了しました。

* [x] プロジェクトを作成する
* [x] Connect Stateに遷移する
    - [x] ManualStart Eventを発生させる
* [x] OpenSent Stateに遷移する
    - [x] TCPコネクションを作成する
* [x] OpenConfirm Stateに遷移する
    - [x] BGP Open Messageを送信する
    - [x] BGP Open Messageを受信する
* [x] Established Stateに遷移する
    - [x] BGP Keepalive Messageを送信する
    - [x] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


現段階の全体のコードを記載します。GitHub上で閲覧したい方は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first[GitHub-現段階の全体のコード]を参照してください。

----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── bgp
│   │   ├── config.rs
│   │   ├── message.rs
│   │   ├── mod.rs
│   │   ├── peer.rs
│   │   ├── queue.rs
│   │   └── timer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title=Cargo.toml]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first/Cargo.toml[]
----

[source,rust,linenums,title=src/bgp/config.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first/src/bgp/config.rs[]
----

[source,rust,linenums,title=src/bgp/message.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first/src/bgp/message.rs[]
----

[source,rust,linenums,title=src/bgp/mod.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first/src/bgp/mod.rs[]
----

[source,rust,linenums,title=src/bgp/peer.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first/src/bgp/peer.rs[]
----

[source,rust,linenums,title=src/bgp/queue.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first/src/bgp/queue.rs[]
----

[source,rust,linenums,title=src/bgp/timer.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first/src/bgp/timer.rs[]
----

[source,rust,linenums,title=src/lib.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/803b9cd401f2ac85cdabc16516ee76099bfdcb14/mrbgpdv2first/src/lib.rs[]
----


=== メイン関数の追加
次は下記に取り組みましょう。

* [ ] main関数を作成する

今までのテストからほとんど自明ですが、下記の感じでどうでしょうか。

[source,rust,linenums,title=src/bgp/config.rs]
----
 use crate::bgp;
 use std::{net::Ipv4Addr, str::FromStr};
+
+#[derive(Debug)]
 pub struct Config {
     pub local_as_number: bgp::AutonomousSystemNumber,
     pub local_ip_address: Ipv4Addr,
----

[source,rust,linenums,title=src/main.rs]
----
+#[macro_use]
+extern crate log;
+use std::{env, thread, time};
+use mrbgpdv2first::bgp::config::Config;
+use mrbgpdv2first::bgp::peer::Peer;
+
 fn main() {
-    println!("Hello, world!");
+    env_logger::init();
+    let args: Vec<String> = env::args().collect();
+    let config: Config = args[1..].join(" ").parse().unwrap();
+    debug!("{:?}", config);
+    let mut p = Peer::new(config);
+    p.start();
+    loop {
+        p.next_step();
+        thread::sleep(time::Duration::from_secs_f32(0.1));
+    }
 }
----


=== テストする
最後のタスクに取り掛かりましょう。

* [ ] テストする

複数台のコンピュータを使用して、本BGPデーモンがEstablished Stateに遷移することができるかテストしてみましょう。

テスト用にVirtualboxやVMwareなどの仮想化ツールを使用して以下のようなネットワークを組みましょう。

host-onlyネットワークのhost-computerとubuntu1でピアリングします。
NATネットワークはubuntu1がインターネットの疎通を取るために用意しています。

[nwdiag]
----
nwdiag {
  network host-only {
    address = "172.16.1.0/24"
    ubuntu1 [address = "172.16.1.128"]
    host-computer [address = "172.16.1.1"]
  }

  network NAT {
    address = "192.168.90.0/24";

    host-computer [address = "192.168.90.1"]
    ubuntu1 [address = "192.168.90.128"]
    }

  network for-internet {
      address = "192.168.1.0/24"

      host-computer [address = "192.168.1.110"]
      router [address = "192.168.1.1"]
  }

  network internet {
      address = "x.x.x.x"
      router
  }
}
----

テスト用の環境が構築できたら、実際に動かしてみましょう。
動かしたログが下記です。
想定通り2台でBGP Keepaliveのやり取りが行われ正常に動いている様子が確認できます。

[source,title="host-computerのログ"]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ sudo RUST_LOG=info ./target/debug/mrbgpdv2first 64512 172.16.1.1 64513 172.16.1.128 active
[2021-05-17T00:33:47Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 172.16.1.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-17T00:33:47Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 172.16.1.128, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-17T00:33:47Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
[2021-05-17T00:33:47Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
----

[source,title="ubuntu1のログ"]
----
mrcsce@ubuntu-1:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ sudo RUST_LOG=info ./target/debug/mrbgpdv2first 64513 172.16.1.128 64512 172.16.1.1 passive
[2021-05-17T00:33:47Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 172.16.1.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-17T00:33:47Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 172.16.1.128, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-17T00:33:47Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
[2021-05-17T00:33:47Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
^C
mrcsce@ubuntu-1:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ 
----

これで一旦Establishedに至るまでの内容は完成です。
あとはこれに肉付けしていくことで、BGPデーモンを完成させることが出来ます。

=== 細かいリファクタリング
さて、肉付けしていく前にいくつかリファクタリングをしましょう。
Rustのフォーマットツール / Linterである、cargo fmt / cargo clippyを適用しました。

なお、ステートマシンにたいして出力される下記警告については無視することにしました。
本来たくさんあるArmを、今現在は1つしか書いていないために出力されているからです。

----
you seem to be trying to use `match` for an equality check. Consider using `if`
----

これで、この段階までの内容は完成です。
現時点のコードを載せます。

[source,rust,linenums,title=Cargo.toml]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/Cargo.toml[]
----

[source,rust,linenums,title=src/bgp/config.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/src/bgp/config.rs[]
----

[source,rust,linenums,title=src/bgp/message.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/src/bgp/message.rs[]
----

[source,rust,linenums,title=src/bgp/mod.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/src/bgp/mod.rs[]
----

[source,rust,linenums,title=src/bgp/peer.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/src/bgp/peer.rs[]
----

[source,rust,linenums,title=src/bgp/queue.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/src/bgp/queue.rs[]
----

[source,rust,linenums,title=src/bgp/timer.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/src/bgp/timer.rs[]
----

[source,rust,linenums,title=src/lib.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/src/lib.rs[]
----

[source,rust,linenums,title=src/main.rs]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f56a055001b501aed8aecb1492e32668ff7143e9/mrbgpdv2first/src/main.rs[]
----

== 1つのピアでUpdate Messageの交換やUpdate Messageの内容にしたがってRouting Tableへの書き込みが可能な実装

ここからは、本当にルーティングテーブルを更新するのに必要な作業に入っていきましょう。
BGPでは、Peer間で、ルーティングの情報をUpdate Messageと呼ばれるメッセージによって交換し合います。

=== 作業の明確化
本項で行う作業を明確化します。

* [ ] ルーティングテーブルの読みを可能にする
* [ ] ルーティングテーブルへの書き込みを可能にする
* [ ] BGP Update Messageを送信可能にする
* [ ] BGP Update Messageの受信を可能にする

=== ルーティングテーブルの読みを可能にする。
Linuxでルーティングテーブルを読んだり、書いたりするためには、netlinkというものを使用します。
netlinkはKernelとユーザ空間で情報をやり取りするためのものです。
netlinkを生で扱うのは難しいため、本書ではライブラリを使用します。

https://github.com/little-dude/netlink 

Cargo.tomlにライブラリ類を追記しましょう。

[source,rust,linenums,title=src/Cargo.toml]
----
[dependencies]
 log = "0.4.0"
+rtnetlink = "0.7.0"
+tokio = { version = "1.0.1", features = ["full"] }
+futures = "0.3.11"
----

RoutingTableの捜査を行うためのモジュール、routing.rsを作成します。
[source,rust,linenums,title=src/lib.rs]
----
b/mrbgpdv2second/src/lib.rs
 extern crate log;
 
 pub mod bgp;
+pub mod routing;
----


RoutingTableをLookupするテストをrouting.rsに追加しましょう。
今回は次のように設計しました。lookup_routing_table(&IpPrefix)という関数がもっとも作成したい関数です。
IpPrefixという型を引数に取り、そのIpPrefixに宛先アドレスが含まれるルーティングテーブルのエントリをVec<RoutingTableEntry>として返します。
RoutingTableEntryは一つのRoutingTableのエントリーを表しています。
なおテスト対象の関数の戻り値や期待される出力を集合に変換しているのは、Vecの順番に非依存にさせるためです。

なおこのテストは自分の環境のルーティングテーブルに依存しています。適時expected_routing_entriesの値を書き換えてください。
本来は環境に依存するテストはよくないですが、ルーティングテーブルのLookupを環境非依存でテストするのが難しいため妥協しています。

[source,rust,linenums,title=src/routing.rs]
----
src/routing.rs
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::collections::HashSet;
+
+    fn init() {
+        let _ = env_logger::builder().is_test(true).try_init();
+    }
+
+    #[test]
+    fn test_lookup_routing_table() {
+        init();
+        let lookup_addr: IpPrefix = "10.0.2.0/24".parse().unwrap();
+        let routing_entries: HashSet<RoutingTableEntry> =
+            lookup_routing_table(&lookup_addr).into_iter().collect();
+        let expected_routing_entries: HashSet<RoutingTableEntry> = vec![
+            RoutingTableEntry::new("10.0.2.0/24".parse().unwrap(), Nexthop::DirectConected),
+            RoutingTableEntry::new("10.0.2.2/32".parse().unwrap(), Nexthop::DirectConected),
+            RoutingTableEntry::new("10.0.2.0/32".parse().unwrap(), Nexthop::DirectConected),
+            RoutingTableEntry::new("10.0.2.255/32".parse().unwrap(), Nexthop::DirectConected),
+            RoutingTableEntry::new("10.0.2.15/32".parse().unwrap(), Nexthop::DirectConected),
+        ]
+        .into_iter()
+        .collect();
+        let difference: HashSet<RoutingTableEntry> = routing_entries
+            .symmetric_difference(&expected_routing_entries)
+            .cloned()
+            .collect();
+        assert!(difference.is_empty());
+    }
+}
----

さて、このテストを通るようにコードを書きましょう。
以下の変更でテストが通ります。

一番大事な関数はlookup_routing_tableです。
lookup_routing_table関数内でnetlinkを用いてルーティング情報を取得し、
それを本ソフトウェア中でのルーティング情報, RoutingTableEntryに変換しています。

非同期プログラミングの複雑さを今の段階では隠すため、
netlinkでの問い合わせをrt.block_on()にて同期的に実行しています。
第4章にて、完成度を高める際に他の通信部分と一緒に非同期にします。

[source,rust,linenums,title=src/routing.rs]
----
+use futures::TryStreamExt;
+use rtnetlink::packet::RouteMessage;
+use rtnetlink::{new_connection, IpVersion};
+use std::net::IpAddr;
+use std::net::Ipv4Addr;
+use std::str::FromStr;
+use tokio::runtime::Runtime;
+
+#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
+struct RoutingTableEntry {
+    network_address: IpPrefix,
+    nexthop: Nexthop,
+}
+
+#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
+enum Nexthop {
+    Ipv4Addr(Ipv4Addr),
+    DirectConected,
+}
+
+impl RoutingTableEntry {
+    fn new(network_address: IpPrefix, nexthop: Nexthop) -> Self {
+        if !network_address.is_network_address() {
+            panic!(
+                "This address of routing table entry is
+                    not network address: {:?}",
+                network_address
+            );
+        }
+        Self {
+            network_address,
+            nexthop,
+        }
+    }
+
+    fn from_route_message(route_message: &RouteMessage) -> Self {
+        let (dest_addr, prefix) = match route_message.destination_prefix() {
+            Some((dest_addr, prefix)) => (dest_addr, prefix),
+            None => (IpAddr::V4("0.0.0.0".parse().unwrap()), 0),
+        };
+        let network_address = match dest_addr {
+            IpAddr::V4(ip_addr) => IpPrefix { ip_addr, prefix },
+            _ => unimplemented!(),
+        };
+
+        let nexthop = if route_message.gateway().is_some() {
+            match route_message.gateway().unwrap() {
+                IpAddr::V4(ip_addr) => Nexthop::Ipv4Addr(ip_addr),
+                _ => unimplemented!(),
+            }
+        } else if route_message.output_interface().is_some() {
+            Nexthop::DirectConected
+        } else {
+            panic!()
+        };
+
+        Self {
+            network_address,
+            nexthop,
+        }
+    }
+}
+
+#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
+struct IpPrefix {
+    ip_addr: Ipv4Addr,
+    prefix: u8,
+}
+
+impl IpPrefix {
+    fn is_network_address(&self) -> bool {
+        let netmask = self.get_subnet_netmask();
+        let ip_addr_bit: u32 = self.ip_addr.into();
+        netmask | ip_addr_bit == netmask
+    }
+
+    fn does_include(&self, other: &IpPrefix) -> bool {
+        if self.prefix > other.prefix {
+            return false;
+        }
+        let self_netmask = self.get_subnet_netmask();
+        let self_ip_addr_bit: u32 = self.ip_addr.into();
+        let other_ip_addr_bit: u32 = other.ip_addr.into();
+        self_netmask & other_ip_addr_bit == self_ip_addr_bit
+    }
+
+    fn get_subnet_netmask(&self) -> u32 {
+        let mut netmask: u32 = 0;
+        for i in 0..self.prefix {
+            netmask += 1 << i;
+        }
+        netmask << (32 - self.prefix)
+    }
+}
+
+#[derive(Debug)]
+struct ParseIpPrefixError;
+
+impl FromStr for IpPrefix {
+    type Err = ParseIpPrefixError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let s: Vec<&str> = s.split('/').collect();
+        let ip_addr: Ipv4Addr = s[0].parse().or(Err(ParseIpPrefixError))?;
+        let prefix: u8 = s[1].parse().or(Err(ParseIpPrefixError))?;
+        Ok(IpPrefix { ip_addr, prefix })
+    }
+}
+
+fn lookup_routing_table(lookup_addr: &IpPrefix) -> Vec<RoutingTableEntry> {
+    let mut route_messages: Vec<RouteMessage> = vec![];
+    let rt = Runtime::new().unwrap();
+    rt.block_on(async {
+        let (connection, handle, _) = new_connection().unwrap();
+        tokio::spawn(connection);
+        let mut routes = handle.route().get(IpVersion::V4).execute();
+        while let Some(route) = routes.try_next().await.unwrap() {
+            route_messages.push(route);
+        }
+    });
+    route_messages
+        .iter()
+        .map(|m| RoutingTableEntry::from_route_message(m))
+        .filter(|r| lookup_addr.does_include(&r.network_address))
+        .collect()
+}
+
----

さて、テストを実行してみましょう。

----
mrcsce@ubuntu1:~/mrbgpdv2/mrbgpdv2second$ cargo test -- --nocapture --test-threads=1
    Finished test [unoptimized + debuginfo] target(s) in 0.40s
     Running unittests (target/debug/deps/mrbgpdv2second-cb9af644a8ef7b55)
[sudo] password for mrcsce:

running 5 tests
test bgp::peer::tests::peer_can_transition_to_connect ... ok
test bgp::peer::tests::peer_can_transition_to_established ... ok
test bgp::peer::tests::peer_can_transition_to_open_confirm ... ok
test bgp::peer::tests::peer_can_transition_to_open_sent ... ok
test routing::tests::test_lookup_routing_table ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.52s
----

通りましたね！
これで、またタスクが一つ完了になりました。

* [x] ルーティングテーブルの読みを可能にする
* [ ] ルーティングテーブルへの書き込みを可能にする
* [ ] BGP Update Messageを送信可能にする
* [ ] BGP Update Messageの受信を可能にする

=== ルーティングテーブルへの書き込みを可能にする

* [ ] ルーティングテーブルへの書き込みを可能にする

次は上記タスクに取り組みましょう。

まずはテストを書きます。

[source,rust,linenums,title=src/routing.rs]
----
+
+    #[test]
+    fn add_route_to_routing_table() {
+        init();
+        let entry = RoutingTableEntry::new(
+            "192.168.50.0/24".parse().unwrap(),
+            Nexthop::Ipv4Addr("10.0.2.2".parse().unwrap()),
+        );
+        add_route_to_routing_table(&entry);
+        let lookup_result = lookup_routing_table(&entry.network_address);
+        assert!(lookup_result.contains(&entry));
+    }
 }
----

本テストではルーティングテーブルにルートを書き込んだ後に、ルーティングテーブルを書き込んだルートのネットワークアドレスでlookupして、書き込んだルートが実際に書き込まれてることを確認しています。

それでは本テストが通るように改変していきましょう。

[source,rust,linenums,title=src/routing.rs]
----
+fn add_route_to_routing_table(entry: &RoutingTableEntry) {
+    let rt = Runtime::new().unwrap();
+    rt.block_on(async {
+        let (connection, handle, _) = new_connection().unwrap();
+        tokio::spawn(connection);
+        let route = handle.route();
+        let gateway_addr = match &entry.nexthop {
+            &Nexthop::Ipv4Addr(ip_addr) => ip_addr,
+            _ => unimplemented!(),
+        };
+        route
+            .add()
+            .v4()
+            .destination_prefix(entry.network_address.ip_addr, entry.network_address.prefix)
+            .gateway(gateway_addr)
+            .execute()
+            .await
+            .unwrap();
+    })
+}
----

テストを実行してみます。

----
mrcsce@ubuntu1:~/mrbgpdv2/mrbgpdv2second$ cargo test -- --nocapture --test-threads=1
   Compiling mrbgpdv2second v0.1.0 (/home/mrcsce/mrbgpdv2/mrbgpdv2second)
    Finished test [unoptimized + debuginfo] target(s) in 10.79s
     Running unittests (target/debug/deps/mrbgpdv2second-cb9af644a8ef7b55)
[sudo] password for mrcsce: 

running 6 tests
test bgp::peer::tests::peer_can_transition_to_connect ... ok
test bgp::peer::tests::peer_can_transition_to_established ... ok
test bgp::peer::tests::peer_can_transition_to_open_confirm ... ok
test bgp::peer::tests::peer_can_transition_to_open_sent ... ok
test routing::tests::test_add_route_to_routing_table ... ok
test routing::tests::test_lookup_routing_table ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.24s
----

無事通りました。

ただし、現状では2回連続でテストを実行した場合、テストが失敗します。
既にルーティングテーブルに存在するルートを再度書き込もうとした際にResult::Errが帰ってくるためです。

現段階ではとりあえず該当のテストに#[ignore]指定をして、通常時は走らないようにすることで暫定的な対処とします。
第4章の細かい完成度を上げるタイミングで、ルーティングテーブルからルートを削除する関数を追加する予定なので、その段階で恒久的な対処は行うこととします。

[source,rust,linenums,title=src/routing.rs]
----
     #[test]
+    #[ignore]
     fn test_add_route_to_routing_table() {
         init();
----


=== BGP Update Messageを送信可能にする

* [ ] BGP Update Messageを送信可能にする

次は上記タスクに取り組み、BGP Update Messageを送信可能にしましょう。
BGP Update Messageは、ルーティング情報をやり取りするMessageです。
BGP Update Messageは色々な条件で創出されます。
最初ははピアが確立された段階で、ルータAが自身のルーティングテーブル中にあるネットワークあての通信はルータAに送信してよいよ、と周りのルータたちに広報します。
そのため、先にルーティングテーブルの読みを可能にしました。

ピアが確立された段階のBGP Update Messageを送信するためのプログラムを書きます。
まずはテストを書きましょう。

==== 統合テストを書く
ここではDockerを使用して、2コンテナを立ち上げ、コンテナ間で、
BGP Update Messageを送受信した結果、ルーティングテーブルが書き変わっていることを確認することにしましょう。

Docker、Docker-composeを使用して、テスト用の環境を一発で作成できるようにします。

[nwdiag]
----
nwdiag {
  network bgp-test-network {
    address = "10.200.100.0/24"
    host1 [address = "10.200.100.2"]
    host2 [address = "10.200.100.3"]
  }

  network host1-network {
    address = "10.100.210.0/24"
    host1 [address = "10.200.100.2"]
  }

  network host2-network {
      address = "10.100.220.0/24"
      host2 [address = "10.100.220.3"]
  }
}
----

bgp-test-networkでhost1、 host2がBGPのピアリングをします。
host2はhost1に対してhost2-networkを広報します。
host1は広報を受け取ったらhost2-networkへの疎通が取れるようになります。

下記Dockerfile、docker-compose.ymlを用意することで、`docker-compose up --build`一発で前述の環境を用意することができます。
Dockerfile内でgit cloneするディレクトリや、WORKDIRのディレクトリは各自の環境に合わせて設定してください。

[source,docker,linenums,title=tests/host1/Dockerfile]
----
+FROM rust
+
+RUN apt install git
+RUN git clone https://github.com/Miyoshi-Ryota/mrbgpdv2.git
+WORKDIR /mrbgpdv2/mrbgpdv2second
+RUN cargo build
+CMD RUST_LOG=info ./target/debug/mrbgpdv2second "64512 10.200.100.2 64513 10.200.100.3 active"
----

[source,docker,linenums,title=tests/host2/Dockerfile]
----
+FROM rust
+
+RUN apt install git
+RUN git clone https://github.com/Miyoshi-Ryota/mrbgpdv2.git
+WORKDIR /mrbgpdv2/mrbgpdv2second
+RUN cargo build
+CMD RUST_LOG=info ./target/debug/mrbgpdv2second "64513 10.200.100.3 64512 10.200.100.2 passive"
----


[source,yaml,linenums,title=/tests/docker-compose.yml]
----
+services:
+  host1:
+    cap_add: 
+      - NET_ADMIN # NET_ADMINがないと、ルーティングテーブルの操作ができない。
+    build: ./host1
+    networks:
+      bgp-test-network:
+        ipv4_address: 10.200.100.2
+      host1-network:
+        ipv4_address: 10.100.210.2
+    depends_on:
+      - host2 # host2から起動するようにしているのは、現状の実装ではBGPのpassiveモード側から起動しないとネイバーがはれないため。
+  host2:
+    cap_add: 
+      - NET_ADMIN # NET_ADMINがないと、ルーティングテーブルの操作ができない。
+    build: ./host2
+    networks:
+      bgp-test-network:
+        ipv4_address: 10.200.100.3
+      host2-network:
+        ipv4_address: 10.100.220.3
+
+networks:
+  bgp-test-network: # host1, host2がピアリングするためのネットワーク
+    driver: bridge
+    ipam:
+      config:
+        - subnet: 10.200.100.0/24
+          gateway: 10.200.100.1
+  host1-network:
+    driver: bridge
+    ipam:
+      config:
+        - subnet: 10.100.210.0/24
+  host2-network: # host2 -> host1にアドバタイズするネットワーク
+    driver: bridge
+    ipam:
+      config:
+        - subnet: 10.100.220.0/24
----


さて、テストとしてこれらのDockerの環境を作成・使用し、host1 から host2-networkへの疎通があることを確認するshellscriptを用意します。

[source,shellscript,linenums,title=tests/run_integration_test.sh]
----
+#! /bin/bash
+docker-compose build --no-cache
+docker-compose up &
+
+# dockerコンテナの起動が終わるまで待つ
+while ! docker container ls | grep tests_host2 > /dev/null
+do
+    sleep 1
+done
+
+# dockerコンテナ内でコンパイルが終了しプロセスの起動が終わるまで待つ
+while ! docker exec tests_host2_1 ps | grep bgp > /dev/null
+do
+    sleep 1
+done
+
+while ! docker exec tests_host1_1 ps | grep bgp > /dev/null
+do
+    sleep 1
+done
+
+# docker execは実行したコマンドの終了コードをそのまま返す。pingは1パケットでも通ったら終了コード0、全部パケロスすると1が返す。
+HOST_2_LOOPBACK_IP=10.100.220.3
+docker exec tests_host1_1 ping -c 5 $HOST_2_LOOPBACK_IP
+TEST_RESULT=$?
+
+
+
+docker-compose down
+ESC=$(printf '\033')
+if [ $TEST_RESULT -eq 0 ]; then
+    printf "${ESC}[32m%s${ESC}[m\n" "統合テストが成功しました。"
+else
+    printf "${ESC}[31m%s${ESC}[m\n" "統合テストが失敗しました。"
+fi
+
----

さて、テストが失敗することを確認しましょう。
----
miyoshi-ryota in ~/Documents/programming/RustProjects/mrbgpdv2/mrbgpdv2second/tests on branch 統合テストの追加 > ./run_integration_test.sh
Building host2
Step 1/6 : FROM rust
 ---> ceae1d63f79e
Step 2/6 : RUN apt install git
 ---> Running in 4446c4cc8140

WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

Reading package lists...
Building dependency tree...
Reading state information...
git is already the newest version (1:2.20.1-2+deb10u3).
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Removing intermediate container 4446c4cc8140
 ---> 3bd122e0df90
Step 3/6 : RUN git clone https://github.com/Miyoshi-Ryota/mrbgpdv2.git
 ---> Running in e5e4ffab8d04
Cloning into 'mrbgpdv2'...
Removing intermediate container e5e4ffab8d04
 ---> 224c92879d95
Step 4/6 : WORKDIR /mrbgpdv2/mrbgpdv2second
 ---> Running in 3b34b02ca627
Removing intermediate container 3b34b02ca627
 ---> 1511e3579006
Step 5/6 : RUN cargo build
 ---> Running in a05726aece36
    Updating crates.io index
~~~~ビルドのログを省略~~~~~
Removing intermediate container a05726aece36
 ---> 7248f6ccafcb
Step 6/6 : CMD RUST_LOG=info ./target/debug/mrbgpdv2second "64513 10.200.100.3 64512 10.200.100.2 passive"
 ---> Running in 73bfbadc09d1
Removing intermediate container 73bfbadc09d1
 ---> 681b0d211db4

Successfully built 681b0d211db4
Successfully tagged tests_host2:latest
Building host1
Step 1/6 : FROM rust
 ---> ceae1d63f79e
Step 2/6 : RUN apt install git
 ---> Running in 04b6040d65f4

WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

Reading package lists...
Building dependency tree...
Reading state information...
git is already the newest version (1:2.20.1-2+deb10u3).
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Removing intermediate container 04b6040d65f4
 ---> c7bef9e0ed53
Step 3/6 : RUN git clone https://github.com/Miyoshi-Ryota/mrbgpdv2.git
 ---> Running in 17adb5332843
Cloning into 'mrbgpdv2'...
Removing intermediate container 17adb5332843
 ---> 35a202416ef6
Step 4/6 : WORKDIR /mrbgpdv2/mrbgpdv2second
 ---> Running in be5f3e072f73
Removing intermediate container be5f3e072f73
 ---> 7a125a13700b
Step 5/6 : RUN cargo build
 ---> Running in cc587538d1ce
 ~~~~ビルドのログを省略~~~~~

 Removing intermediate container cc587538d1ce
 ---> d1ab9299603f
Step 6/6 : CMD RUST_LOG=info ./target/debug/mrbgpdv2second "64512 10.200.100.2 64513 10.200.100.3 active"
 ---> Running in 29bc7bcc7f2a
Removing intermediate container 29bc7bcc7f2a
 ---> 7e982c6a2d3c

Successfully built 7e982c6a2d3c
Successfully tagged tests_host1:latest
Creating network "tests_bgp-test-network" with driver "bridge"
Creating network "tests_host2-network" with driver "bridge"
Creating network "tests_host1-network" with driver "bridge"
Creating tests_host2_1 ... done
Creating tests_host1_1 ... done
Attaching to tests_host2_1, tests_host1_1
host2_1  | [2021-08-18T22:26:12Z INFO  mrbgpdv2second::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 10.200.100.3, optional_parameter_length: 0, optional_parameters: [] })
host1_1  | [2021-08-18T22:26:12Z INFO  mrbgpdv2second::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 10.200.100.2, optional_parameter_length: 0, optional_parameters: [] })
host1_1  | [2021-08-18T22:26:12Z INFO  mrbgpdv2second::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 10.200.100.3, optional_parameter_length: 0, optional_parameters: [] })
host1_1  | [2021-08-18T22:26:12Z INFO  mrbgpdv2second::bgp::peer] Send bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
host2_1  | [2021-08-18T22:26:12Z INFO  mrbgpdv2second::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 10.200.100.2, optional_parameter_length: 0, optional_parameters: [] })
host2_1  | [2021-08-18T22:26:12Z INFO  mrbgpdv2second::bgp::peer] Send bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
host1_1  | [2021-08-18T22:26:12Z INFO  mrbgpdv2second::bgp::peer] Recive bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
host2_1  | [2021-08-18T22:26:12Z INFO  mrbgpdv2second::bgp::peer] Recive bgp message Keepalive(BgpKeepaliveMessage { header: BgpMessageHeader { length: 19, type_: Keepalive } })
PING 10.100.220.3 (10.100.220.3) 56(84) bytes of data.

--- 10.100.220.3 ping statistics ---
5 packets transmitted, 0 received, 100% packet loss, time 110ms

Stopping tests_host1_1 ... 
Stopping tests_host1_1 ... done
Stopping tests_host2_1 ... done
tests_host2_1 exited with code 137
Removing tests_host1_1 ... done
Removing tests_host2_1 ... done
Removing network tests_bgp-test-network
Removing network tests_host2-network
Removing network tests_host1-network
統合テストが失敗しました。
miyoshi-ryota in ~/Documents/programming/RustProjects/mrbgpdv2/mrbgpdv2second/tests on branch 統合テストの追加 > 
----

このように現状の実装ではテストが失敗することが確認取れました。

さて、BGPのUpdateメッセージのやり取りを実装します。
この実装によって、host1のルーティングテーブルが更新されるようになると、本テストが成功するはずです。

==== BGP Update Messageのやり取りの実装内容の説明。
BGP Update Messageを送信する内部のプロセスは複雑です。
概要を掴みやすくするためにコードを用いた説明の前に自然言語で説明をします。

説明のためにLoc-RIB, Adj-RIB-In, Adj-RIB-Outの3つの用語を導入します。これらはBGPのRFCで用いられている用語です。

.Table 用語の説明
|===
|用語 | 説明

|Loc-RIB
|Local Routing Information Baseの略。要はただのルーティングテーブル。

|Adj-RIB-In
|BGPのネイバーから受信したルーティング情報。

|Adj-RIB-Out
|BGPのネイバーに送信する / したルーティング情報。
|===

これらの用語を使用してBGPのアップデートメッセージが送信されるまでのプロセスを見ていきましょう。

BGPのアップデートメッセージに関するプロセスは決定プロセス、送信プロセスに分けられます。
決定プロセスでは、Adj-RIB-InのルートからLoc-RIB及びAdj-RIB-Outに格納するルートを選択します。
送信プロセスではAdj-RIB-Outの情報をピアに送信します。

もう少し詳細に踏み込みます。決定プロセスはさらに次のPhase1, Phase2, Phase3に分けられます。

* Phase1: Adj-RIB-InのRouteの優先度合いを計算する。
* Phase2: Phase1で計算したRouteの優先度を使用して、Loc-RIBに格納するルートを選択し、そのルートをLoc-RIBに格納する。
* Phase3: Loc-RIBからAdj-RIB-Outに格納するルートを選択し、そのルートをAdj-RIB-Outに格納する。

送信プロセスでは、Adj-RIB-Outの情報からピアにUpdate Messageを送進します。
例えば、以前にUpdate Messageで送信したルートと同じルートは弾きます。Adj-RIB-Outから削除されたルートはピアに削除するようにwithdrawnとして送信する、などのことを行います。

これらのプロセスを全て、今までのイベント駆動ステートマシンで扱うことにします。そのために以下のイベントを定義します。

.Table 導入するEvent一覧
|===
|Event Name | 説明

|Update Msg
|Update Messageを受信した時に発行されるイベント。RFCに定義されているまま。

|Loc-RIB-Changed
|Loc-RIBが更新された時に発行されるイベント。RFCには定義されていない。このイベントを導入する方が実装が簡単で、今までとほとんど同じコードを書くだけで実装できるため導入した。

|Adj-RIB-In-Changed
|Adj-RIB-Inが更新された時に発行されるイベント。RFCには定義されていない。このイベントを導入する方が実装が簡単で、今までとほとんど同じコードを書くだけで実装できるため導入した。

|Adj-RIB-Out-Changed
|Adj-RIB-Outが更新された時に発行されるイベント。RFCには定義されていない。このイベントを導入する方が実装が簡単で、今までとほとんど同じコードを書くだけで実装できるため導入した。
|===

以下のタイミングで実施することにします。

- 決定プロセス
    - Phase1: Adj-RIB-Inが変更された時。（RFCではUpdate Messageを受信した時と定義されている。）
    - Phase2: Phase1終了時。（RFCではPhase1が終了した時と定義されている）
    - Phase3: Loc-RIBが変更された時。（RFCではLoc-RIBが変更された時、自分のルーティングテーブルが書き変わった時、新しくBGPピアがEstablishedなった時と定義されている。）
- 送信プロセス: Adj-RIB-Outが変更された時。（RFCでは特に定義されていない。）

これら導入した概念を使用して実装するイベント駆動ステートマシンを図にします。

[plantuml,title="Update Messageの送信プロセス"]
----
@startuml

state Idle
state Connect
state OpenConfirm
state OpenSent
state Established

[*] --> Idle
Idle --> Connect : ManualStart event
note on link
   対向側機器とTCPコネクションを作成を試みる。
end note

Connect --> OpenSent : Tcp_CR_Acked | TcpConnectionConfirmed event
note on link
   対向側機器にBGP OpenMessageを送信する。
end note

OpenSent --> OpenConfirm : BGPOpen event
note on link
    対向機器にBGP Keepalive Messageを送信する。
end note

OpenConfirm --> Established : KeepAliveMsg event
note on link
自身のルーティングテーブルをLoc-RIBに格納する。
end note

Established --> Established : UpdateMsg event
note on link
Adj-RIB-Inを更新する。
end note

Established --> Established : Adj-Rib-In-Changed
note on link
決定プロセスPhase1を実行する。
決定プロセスPhase2を実行する。（Loc-Ribを更新する。）
end note

Established --> Established : Loc-Rib-Changed
note on link
決定プロセスPhase3を実行する。（Adj-Rib-Outを更新する。）
end note

Established --> Established : Adj-Rib-Out-Changed
note on link
送信プロセスを実行する。（Update Messageを送信する。）
end note


@enduml
----

==== BGP Update Messageのやり取りの実装
さて、ここまでで実装するものが明らかになりました。
コードで言えば、下記ToDo部分を実装する必要があります。


[source, rust, linenums, title=src/bgp/mod.rs]
----
+++ b/mrbgpdv2second/src/bgp/mod.rs
@@ -6,5 +6,5 @@ mod rib;
 mod path_attribute;
 mod timer;
 
-#[derive(Debug, Copy, Clone)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
----

[source, rust, linenums, title=src/bgp/peer.rs]
----
        impl Peer {
             State::OpenConfirm => match event {
                 Event::Keepalive => {
                     self.now_state = State::Established;
+                    // ToDo1: 現在のルーティングテーブルの情報をLoc-Ribにインストールする。
                 }
                 _ => {}
             }
-            _ => {}
+            State::Established => match event {
+                Event::UpdateMsg => {
+                    // ToDo4: 受信したUpdate MessageからAdj-RIB-Inを更新する。
+                    unimplemented!();
+                }
+                Event::AdjRibInChanged => {
+                    // ToDo5: Phase1:　Adj-RIB-InからLoc-RIBに格納するルートを選択する。
+                    // ToDo6: Phase2: Phase1の情報を使ってLoc-RIBを更新する。
+                    unimplemented!();
+                }
+                Event::LocRibChanged => {
+                    // ToDo2: Phase3: Loc-RIBからAdj-Rib-Outを更新する。
+                    unimplemented!();
+                }
+                Event::AdjRibOutChanged => {
+                    // ToDo3: Update Messageをピアに送信する。
+                    unimplemented!();
+                }
+                _ => {}
+            },
         }
     }
 }
@@ -196,6 +216,10 @@ pub enum Event {
     TcpConnectionConfirmed,
     BgpOpen,
     Keepalive,
+    UpdateMsg,
+    LocRibChanged,
+    AdjRibInChanged,
+    AdjRibOutChanged,
 }
 
 #[cfg(test)]
----

ToDoコメント内の順番に沿って実装します。

〜〜実装方針として、〜〜
// statusを書き換えるタイミングは考え中
// 実装方針
// Routingtable -> LocRib
// * status: Updated
// * path attributes:
//      * Origin: IGP,
//      * AS_PATH: 無し,
//      * Nexthop: 無し
//      * ATOMIC_AGGREGATEL: 無し
//
// LocRib -> AdjRibOut
// * status: そのまま。ただしAdjRibOutに送信後に自分のStatusはUnChangedに変更する。
// * path attributes:
//       * AS_PATH: 自分のAS番号を追加する。
//       * nexthop: 書き換える。自分のIPに書き換える。routingtableentryのnexthopも書き換える。
//       * その他: そのまま
// AdjRibOut -> external peer
// * status: UpdateMessage送信後にAdjRibOutのStatusはUnChangedにする。
//
// Update Message -> AdjRibIn
// * status: Update or Withdrawnのメッセージのまま
// * path attributes:
//     * そのまま
//
// AdjRibIn -> LocRib
// * AdjRibInのStatusだけ、UnChangedにする。
// * 全部そのまま

それでは下記を実装します。

* ToDo1: 現在のルーティングテーブルの情報をLoc-RIBにインストールする。

[source,rust,linenums,title=src/bgp/mod.rs]
----
@@ -2,6 +2,8 @@ pub mod config;
 mod message;
 pub mod peer;
 mod queue;
+mod rib;
+mod path_attribute;
 mod timer;
----

[source,rust,linenums,title=src/bgp/peer.rs]
----
@@ -5,6 +5,9 @@ use super::{
 use crate::bgp::config::Config;
 use crate::bgp::config::Mode;
 use crate::bgp::message::{BgpMessage, BgpMessageHeader, BgpMessageType};
+use crate::bgp::rib::{LocRib, RibEntry, RibEntryStatus};
+use crate::bgp::path_attribute::{PathAttribute, AsPath};
+use crate::routing::lookup_routing_table;
 use std::{
     io::{self, Read, Write},
     net::{TcpListener, TcpStream},
@@ -17,6 +20,7 @@ pub struct Peer {
     now_state: State,
     tcp_connection: Option<TcpStream>,
     buffer: Vec<u8>,
+    loc_rib: LocRib,
 }
 
 impl Peer {
@@ -26,6 +30,7 @@ impl Peer {
         let now_state = State::Idle;
         let tcp_connection = None;
         let buffer = vec![];
+        let loc_rib = LocRib::new(vec![]);
         Self {
             config,
             event_queue,
@@ -33,6 +38,7 @@ impl Peer {
             now_state,
             tcp_connection,
             buffer,
+            loc_rib,
         }
     }
 
@@ -172,7 +178,22 @@ impl Peer {
             State::OpenConfirm => match event {
                 Event::Keepalive => {
                     self.now_state = State::Established;
-                    // ToDo1: 現在のルーティングテーブルの情報をLoc-Ribにインストールする。
+                    let ribs: Vec<RibEntry> = self
+                        .config
+                        .advertise_networks
+                        .iter()
+                        .map(|network| lookup_routing_table(network))
+                        .flatten()
+                        .map(|entry| {
+                            RibEntry::new(
+                                entry,
+                                RibEntryStatus::Updated,
+                                vec![PathAttribute::Origin("IGP".parse().unwrap()),
+                                PathAttribute::AsPath(AsPath::AsSequence(vec![])),
+                                PathAttribute::NextHop("0.0.0.0".parse().unwrap())],
+                            )
+                        })
+                        .collect();
+                    self.loc_rib.insert_table(ribs);
+                    self.event_queue.enqueue(Event::LocRibChanged);
                 }
                 _ => {}
             },
----

[source,rust,linenums,title=src/bgp/rib.rs]
----
@@ -0,0 +1,45 @@
+use crate::bgp::path_attribute::PathAttribute;
+use crate::routing::{IpPrefix, RoutingTableEntry};
+pub type LocRib = Rib;
+
+pub struct Rib {
+    table: Vec<RibEntry>,
+}
+
+pub struct RibEntry {
+    routing_table_entry: RoutingTableEntry,
+    status: RibEntryStatus,
+    path_attributes: Vec<PathAttribute>,
+}
+
+impl RibEntry {
+    pub fn new(
+        routing_table_entry: RoutingTableEntry,
+        status: RibEntryStatus,
+        path_attributes: Vec<PathAttribute>,
+    ) -> Self {
+        Self {
+            routing_table_entry,
+            status,
+            path_attributes,
+        }
+    }
+}
+
+impl Rib {
+    pub fn new(table: Vec<RibEntry>) -> Self {
+        Self { table }
+    }
+
+    pub fn insert_table(&mut self, table: Vec<RibEntry>) {
+        for entry in table {
+            self.insert_entry(entry);
+        }
+    }
+
+    pub fn insert_entry(&mut self, entry: RibEntry) {
+        if !self.table.contains(&entry) {
+            self.table.push(entry);
+        }
+    }
+}
+impl PartialEq for RibEntry {
+    fn eq(&self, other: &Self) -> bool {
+        self.routing_table_entry.network_address == other.routing_table_entry.network_address
+        && self.path_attributes == other.path_attributes
+    }
+}
+
+pub enum RibEntryStatus {
+    Updated,
+    Withdrawn,
+    UnChanged,
+}
----

[source,rust,linenums,title=src/bgp/config.rs]
----
@@ -1,4 +1,5 @@
 use crate::bgp;
+use crate::routing::IpPrefix;
 use std::{net::Ipv4Addr, str::FromStr};
 
 #[derive(Debug)]
@@ -8,6 +9,7 @@ pub struct Config {
     remote_as_number: bgp::AutonomousSystemNumber,
     pub remote_ip_address: Ipv4Addr,
     pub mode: Mode,
+    pub advertise_networks: Vec<IpPrefix>,
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
@@ -50,12 +52,21 @@ impl FromStr for Config {
 
         let mode = c[4].parse().expect("cannot parse mode");
 
+        let mut advertise_networks = vec![];
+        for advertise_network_str in c[5..].iter() {
+            let advertise_network: IpPrefix = advertise_network_str.parse().expect("cannot parse advertise_network");
+            if !advertise_network.is_network_address() {
+                panic!("advertise_network is not network address");
+            }
+            advertise_networks.push(advertise_network);
+        }
         Ok(Config {
             local_as_number,
             local_ip_address,
             remote_as_number,
             remote_ip_address,
             mode,
+            advertise_networks,
         })
     }
 }
----



[source,rust,linenums,title=src/bgp/path_attributes.rs]
----
@@ -0,0 +1,49 @@
+use std::str::FromStr;
+use std::net::Ipv4Addr;
+use std::collections::HashSet;
+use crate::bgp;
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum PathAttribute {
+    // 全てのルータが認識可能である必要のある最低限のパスアトリビュートのみ実装する。
+    // LOCAL_PREFは、EBGPでは使用しないため、全てのルータが識別可能である必要があるが、今回は省略した。
+    Origin(Origin),
+    AsPath(AsPath),
+    NextHop(Ipv4Addr),
+    AtomicAggregate,
+    DontKnow(Vec<u8>),
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum Origin {
+    Igp,
+    Egp,
+    Incomplete,
+}
+
+#[derive(Debug)]
+pub struct ParseOriginError;
+
+impl FromStr for Origin {
+    type Err = ParseOriginError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        match s {
+            "IGP" => Ok(Origin::Igp),
+            "EGP" => Ok(Origin::Egp),
+            "INCOMPLETE" => Ok(Origin::Incomplete),
+            _ => Err(ParseOriginError),
+        }
+    }
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum AsPath {
+    AsSequence(Vec<bgp::AutonomousSystemNumber>),
+    AsSet(HashSet<bgp::AutonomousSystemNumber>),
+}
+
+impl PathAttribute {
+    pub fn serialize(&self) -> Vec<u8> {
+        unimplemented!();
+    }
+
+    pub fn deserialize(bytes: &[u8]) -> Self {
+        unimplemented!();
+    }
+}
----


[source,rust,linenums,title=src/routing.rs]
----
 use tokio::runtime::Runtime;
 
 #[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
-struct RoutingTableEntry {
-    network_address: IpPrefix,
+pub struct RoutingTableEntry {
+    pub network_address: IpPrefix,
     nexthop: Nexthop,
 }
 
 #[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
-struct IpPrefix {
+pub struct IpPrefix {
     ip_addr: Ipv4Addr,
     prefix: u8,
 }
 
 impl IpPrefix {
-    fn is_network_address(&self) -> bool {
+    pub fn is_network_address(&self) -> bool {
         let netmask = self.get_subnet_netmask();
         let ip_addr_bit: u32 = self.ip_addr.into();
         netmask | ip_addr_bit == netmask

 #[derive(Debug)]
-struct ParseIpPrefixError;
+pub struct ParseIpPrefixError;
  
-fn lookup_routing_table(lookup_addr: &IpPrefix) -> Vec<RoutingTableEntry> {
+pub fn lookup_routing_table(lookup_addr: &IpPrefix) -> Vec<RoutingTableEntry> {
     let mut route_messages: Vec<RouteMessage> = vec![];
     let rt = Runtime::new().unwrap();
     rt.block_on(async {
----

次に下記を実装します。

* ToDo2: Phase3: Loc-RIBからAdj-Rib-Outを更新する。

RibにLocRib => AdjRibOutにルートをインストールするメソッドを実装し、それを呼び出しているだけです。
LocRib => AdjRibOutにインストールする際には、
〜〜〜〜

[source,rust,linenums,title=src/bgp/rib.rs]
----
--- a/mrbgpdv2second/src/bgp/rib.rs
+++ b/mrbgpdv2second/src/bgp/rib.rs
@@ -1,12 +1,19 @@
+use std::net::Ipv4Addr;
+use std::str::FromStr;
+
 use crate::bgp::path_attribute::PathAttribute;
+use crate::bgp::AutonomousSystemNumber;
 use crate::routing::{IpPrefix, RoutingTableEntry};
+
 pub type LocRib = Rib;
 pub type AdjRibOut = Rib;
 
+#[derive(Clone)]
 pub struct Rib {
     table: Vec<RibEntry>,
 }
 
+#[derive(Clone)]
 pub struct RibEntry {
     routing_table_entry: RoutingTableEntry,
     status: RibEntryStatus,
@@ -43,6 +50,36 @@ impl Rib {
             self.table.push(entry);
         }
     }
+
+    pub fn install_route_to_adj_rib_out(
+        &mut self,
+        adj_rib_out: &mut AdjRibOut,
+        local_as_number: AutonomousSystemNumber,
+        local_ip: Ipv4Addr,
+    ) {
+        let mut rib: Vec<RibEntry> = self
+            .table
+            .clone()
+            .into_iter()
+            .filter(|e| &e.status != &RibEntryStatus::UnChanged)
+            .collect();
+
+        let nexthop_addr = Ipv4Addr::from_str("192.168.1.1").unwrap();
+        for entry in &mut rib {
+            for attribute in &mut entry.path_attributes {
+                match attribute {
+                    PathAttribute::AsPath(as_path) => as_path.push(local_as_number),
+                    PathAttribute::NextHop(addr) => *addr = local_ip,
+                    _ => (),
+                }
+            }
+        }
+
+        self.table
+            .iter_mut()
+            .for_each(|e| e.status = RibEntryStatus::UnChanged);
+        adj_rib_out.insert_table(rib);
+    }
 }
 
 
+#[derive(Debug, PartialEq, Eq, Clone)]
 pub enum RibEntryStatus {
     Updated,
     Withdrawn,
----


[source, rust, linenums, title=src/bgp/peer.rs]
----
@@ -1,6 +1,7 @@
 use super::{
+    rib::AdjRibOut,
 };


@@ -21,6 +22,7 @@ pub struct Peer {
     tcp_connection: Option<TcpStream>,
     buffer: Vec<u8>,
     loc_rib: LocRib,
+    adj_rib_out: AdjRibOut,
 }
 
 impl Peer {
@@ -31,6 +33,7 @@ impl Peer {
         let tcp_connection = None;
         let buffer = vec![];
         let loc_rib = LocRib::new(vec![]);
+        let adj_rib_out = AdjRibOut::new(vec![]);
         Self {
             config,
             event_queue,
@@ -39,6 +42,7 @@ impl Peer {
             tcp_connection,
             buffer,
             loc_rib,
+            adj_rib_out,
         }
     }
 
@@ -210,10 +214,11 @@ impl Peer {
                     unimplemented!();
                 }
                 Event::LocRibChanged => {
-                    // ToDo2: Phase3: Loc-RIBからAdj-Rib-Outを更新する。
-                    // adj_rib_outは更新した / 削除した / そのまま/
-                    // self.adj_rib_out.update(&self.loc_rib);
-                    unimplemented!();
+                    self.loc_rib.install_route_to_adj_rib_out(
+                        &mut self.adj_rib_out,
+                        self.config.local_as_number,
+                        self.config.local_ip_address,
+                    );
                 }
                 Event::AdjRibOutChanged => {
                     // ToDo3: Update Messageをピアに送信する。
----


[source,rust,linenums,title=src/routing.rs]
----
diff --git a/mrbgpdv2second/src/bgp/path_attribute.rs b/mrbgpdv2second/src/bgp/path_attribute.rs
index 41f8c9f..bbc8845 100644
--- a/mrbgpdv2second/src/bgp/path_attribute.rs
+++ b/mrbgpdv2second/src/bgp/path_attribute.rs
@@ -1,10 +1,9 @@
 use crate::bgp;
+use std::collections::HashSet;
+use std::net::Ipv4Addr;
+use std::str::FromStr;
 
-#[derive(Debug, PartialEq, Eq)]
+#[derive(Debug, PartialEq, Eq, Clone)]
 pub enum PathAttribute {
 
-#[derive(Debug, PartialEq, Eq)]
+#[derive(Debug, PartialEq, Eq, Clone, Copy)]
 pub enum Origin {
 
-#[derive(Debug, PartialEq, Eq)]
+#[derive(Debug, PartialEq, Eq, Clone)]
 pub enum AsPath {
 
+impl AsPath {
+    pub fn push(&mut self, as_number: bgp::AutonomousSystemNumber) {
+        match self {
+            AsPath::AsSequence(seq) => seq.push(as_number),
+            AsPath::AsSet(set) => {
+                set.insert(as_number);
+            }
+        }
+    }
+}
+
----

次に下記を実装しましょう。

* ToDo3: Update Messageをピアに送信する。

[source, rust, linenums, title=src/bgp/message.rs]
----
diff --git a/mrbgpdv2second/src/bgp/message.rs b/mrbgpdv2second/src/bgp/message.rs
index 9a25384..508401f 100644
--- a/mrbgpdv2second/src/bgp/message.rs
+++ b/mrbgpdv2second/src/bgp/message.rs
@@ -1,11 +1,15 @@
 use super::timer::HoldTime;
 use super::AutonomousSystemNumber;
-use std::{convert::TryInto, net::Ipv4Addr};
+use crate::bgp::path_attribute::PathAttribute;
+use crate::bgp::rib::AdjRibOut;
+use crate::routing::IpPrefix;
+use std::{borrow::Borrow, convert::TryInto, net::Ipv4Addr};
 
 #[derive(Debug)]
 pub enum BgpMessage {
     Open(BgpOpenMessage),
     Keepalive(BgpKeepaliveMessage),
+    Update(BgpUpdateMessage),
 }
 
 impl BgpMessage {
@@ -13,6 +17,7 @@ impl BgpMessage {
         match self {
             BgpMessage::Open(open) => open.serialize(),
             BgpMessage::Keepalive(keepalive) => keepalive.serialize(),
+            BgpMessage::Update(update) => update.serialize(),
         }
     }
 
@@ -23,6 +28,7 @@ impl BgpMessage {
             BgpMessageType::Keepalive => {
                 BgpMessage::Keepalive(BgpKeepaliveMessage::deserialize(bytes))
             }
+            BgpMessageType::Update => BgpMessage::Update(BgpUpdateMessage::deserialize(bytes)),
         }
     }
 
@@ -30,6 +36,7 @@ impl BgpMessage {
         match self {
             BgpMessage::Open(_) => BgpMessageType::Open,
             BgpMessage::Keepalive(_) => BgpMessageType::Keepalive,
+            BgpMessage::Update(_) => BgpMessageType::Update,
         }
     }
 }
@@ -63,12 +70,14 @@ impl BgpMessageHeader {
 pub enum BgpMessageType {
     Open,
     Keepalive,
+    Update,
 }
 
 impl BgpMessageType {
     fn to_type_number(self) -> u8 {
         match self {
             BgpMessageType::Open => 1,
+            BgpMessageType::Update => 2,
             BgpMessageType::Keepalive => 4,
         }
     }
@@ -76,6 +85,7 @@ impl BgpMessageType {
     fn from_type_number(type_number: u8) -> Self {
         match type_number {
             1 => BgpMessageType::Open,
+            2 => BgpMessageType::Update,
             4 => BgpMessageType::Keepalive,
             _ => panic!(),
         }
@@ -180,3 +190,107 @@ impl BgpKeepaliveMessage {
         Self { header }
     }
 }
+
+#[derive(Debug)]
+pub struct BgpUpdateMessage {
+    header: BgpMessageHeader,
+    withdrawn_routes_length: u16,
+    withdrawn_routes: Vec<IpPrefix>,
+    total_path_attribute_length: u16,
+    path_attributes: Vec<PathAttribute>,
+    network_layer_reachability_information: Vec<IpPrefix>,
+}
+
+impl BgpUpdateMessage {
+    pub fn new(
+        path_attributes: Vec<PathAttribute>,
+        withdrawn_routes: Vec<IpPrefix>,
+        network_layer_reachability_information: Vec<IpPrefix>,
+    ) -> Self {
+        let total_path_attribute_length: u16 = path_attributes
+            .iter()
+            .map(|p| p.serialize().len().try_into().unwrap())
+            .fold(0, |acc, a: u16| a + acc);
+        let withdrawn_routes_length: u16 = withdrawn_routes
+            .iter()
+            .map(|r| r.serialize().len().try_into().unwrap())
+            .fold(0, |acc, a: u16| a + acc);
+        let nlri_routes_length: u16 = network_layer_reachability_information
+            .iter()
+            .map(|r| r.serialize().len().try_into().unwrap())
+            .fold(0, |acc, a: u16| a + acc);
+        let minimum_header_length = 19;
+        let header = BgpMessageHeader {
+            length: minimum_header_length
+                + total_path_attribute_length
+                + withdrawn_routes_length
+                + nlri_routes_length,
+            type_: BgpMessageType::Update,
+        };
+        BgpUpdateMessage {
+            header,
+            withdrawn_routes_length,
+            withdrawn_routes,
+            total_path_attribute_length,
+            path_attributes,
+            network_layer_reachability_information,
+        }
+    }
+
+    fn serialize(&self) -> Vec<u8> {
+        let mut bytes = vec![];
+        bytes.append(&mut self.header.serialize());
+        bytes.append(&mut self.withdrawn_routes_length.to_be_bytes().to_vec());
+        bytes.append(
+            &mut self
+                .withdrawn_routes
+                .iter()
+                .map(|r| r.serialize())
+                .flatten()
+                .collect(),
+        );
+        bytes.append(&mut self.total_path_attribute_length.to_be_bytes().to_vec());
+        bytes.append(
+            &mut self
+                .path_attributes
+                .iter()
+                .map(|p| p.serialize())
+                .flatten()
+                .collect(),
+        );
+        bytes.append(
+            &mut self
+                .network_layer_reachability_information
+                .iter()
+                .map(|r| r.serialize())
+                .flatten()
+                .collect(),
+        );
+        bytes
+    }
+
+    fn deserialize(bytes: &[u8]) -> Self {
+        unimplemented!();
+    }
+}
+
+impl IpPrefix {
+    pub fn serialize(&self) -> Vec<u8> {
+        let mut bytes = vec![];
+        bytes.push(self.prefix);
+        let ip_addr_octates = match self.prefix {
+            0 => 0,
+            1..=8 => 1,
+            9..=16 => 2,
+            17..=24 => 3,
+            25..=32 => 4,
+            _ => panic!(),
+        };
+        bytes.append(&mut self.ip_addr.octets()[0..ip_addr_octates].to_vec());
+        bytes
+    }
+
+    fn deserialize(bytes: &[u8]) -> Self {
+        unimplemented!();
+    }
+}
----

[source,rust,linenums,title=src/bgp/mod.rs]
----
diff --git a/mrbgpdv2second/src/bgp/mod.rs b/mrbgpdv2second/src/bgp/mod.rs
index 2220311..8199a2d 100644
--- a/mrbgpdv2second/src/bgp/mod.rs
+++ b/mrbgpdv2second/src/bgp/mod.rs
@@ -6,5 +6,5 @@ mod queue;
 mod rib;
 mod timer;
 
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
 pub struct AutonomousSystemNumber(u16);
----

[source,rust,linenums,title=src/bgp/path_attribute.rs]
----
diff --git a/mrbgpdv2second/src/bgp/path_attribute.rs b/mrbgpdv2second/src/bgp/path_attribute.rs
index bbc8845..c0bf6ed 100644
--- a/mrbgpdv2second/src/bgp/path_attribute.rs
+++ b/mrbgpdv2second/src/bgp/path_attribute.rs
@@ -1,9 +1,11 @@
 use crate::bgp;
-use std::collections::HashSet;
+use std::collections::BTreeSet;
+use std::convert::TryInto;
 use std::net::Ipv4Addr;
 use std::str::FromStr;
+use std::vec;
 
-#[derive(Debug, PartialEq, Eq, Clone)]
+#[derive(Debug, PartialEq, Eq, Clone, Hash)]
 pub enum PathAttribute {
     // 全てのルータが認識可能である必要のある最低限のパスアトリビュートのみ実装する。
     // LOCAL_PREFは、EBGPでは使用しないため、全てのルータが識別可能である必要があるが、今回は省略した。
@@ -14,7 +16,7 @@ pub enum PathAttribute {
     DontKnow(Vec<u8>),
 }
 
-#[derive(Debug, PartialEq, Eq, Clone, Copy)]
+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
 pub enum Origin {
     Igp,
     Egp,
@@ -37,10 +39,10 @@ impl FromStr for Origin {
     }
 }
 
-#[derive(Debug, PartialEq, Eq, Clone)]
+#[derive(Debug, PartialEq, Eq, Clone, Hash)]
 pub enum AsPath {
     AsSequence(Vec<bgp::AutonomousSystemNumber>),
-    AsSet(HashSet<bgp::AutonomousSystemNumber>),
+    AsSet(BTreeSet<bgp::AutonomousSystemNumber>),
 }
 
 impl AsPath {
@@ -56,7 +58,89 @@ impl AsPath {
 
 impl PathAttribute {
     pub fn serialize(&self) -> Vec<u8> {
-        unimplemented!();
+        match self {
+            PathAttribute::Origin(o) => {
+                // attribute_flagの意味。左から
+                // 1bit: attribute is optional (if set to 1) or well-known (if set to 0)
+                // 2bit: It defines whether an optional attribute is
+                //       transitive (if set to 1) or non-transitive (if set to 0). (well-known is transitive)
+                // 3bit: It defines whether the information
+                //       contained in the optional transitive attribute is partial (if
+                //       set to 1) or complete (if set to 0).  For well-known attributes
+                //       and for optional non-transitive attributes, the Partial bit
+                //       MUST be set to 0.
+                // 4bit: It defines whether the Attribute
+                //       Length is one octet (if set to 0) or two octets (if set to 1).
+                let attribute_flag: u8 = 0b01000000;
+                let attribute_type: u8 = 1;
+                let attribute_length: u8 = 1; // octates of attribute bytes
+                let attribute_bytes: u8 = match o {
+                    &Origin::Igp => 0,
+                    &Origin::Egp => 1,
+                    &Origin::Incomplete => 2,
+                };
+                vec![
+                    attribute_flag,
+                    attribute_type,
+                    attribute_length,
+                    attribute_bytes,
+                ]
+            }
+            PathAttribute::AsPath(a) => {
+                let attribute_flag: u8;
+                let attribute_type: u8 = 2;
+                let mut attribute_bytes: Vec<u8> = match a {
+                    AsPath::AsSequence(ases) => {
+                        let as_path_segment_type = 1;
+                        let as_path_segment_length: u8 = ases.len().try_into().unwrap();
+                        let mut as_path_segment: Vec<u8> = ases
+                            .iter()
+                            .map(|a| a.0.to_be_bytes().to_vec())
+                            .flatten()
+                            .collect();
+                        let mut bytes = vec![as_path_segment_type, as_path_segment_length];
+                        bytes.append(&mut as_path_segment);
+                        bytes
+                    }
+                    AsPath::AsSet(ases) => {
+                        let as_path_segment_type = 2;
+                        let as_path_segment_length: u8 = ases.len().try_into().unwrap();
+                        let mut as_path_segment: Vec<u8> = ases
+                            .iter()
+                            .map(|a| a.0.to_be_bytes().to_vec())
+                            .flatten()
+                            .collect();
+                        let mut bytes = vec![as_path_segment_type, as_path_segment_length];
+                        bytes.append(&mut as_path_segment);
+                        bytes
+                    }
+                };
+                let mut attribute_length = vec![];
+                if attribute_bytes.len() >= u8::MAX.into() {
+                    attribute_length.push(attribute_bytes.len().try_into().unwrap());
+                    attribute_flag = 0b01000000;
+                } else {
+                    let l: u16 = attribute_bytes.len().try_into().unwrap();
+                    attribute_length.append(&mut l.to_be_bytes().to_vec());
+                    attribute_flag = 0b01100000
+                }
+                let mut bytes = vec![attribute_flag, attribute_type];
+                bytes.append(&mut attribute_length);
+                bytes.append(&mut attribute_bytes);
+                bytes
+            }
+            PathAttribute::NextHop(ip) => {
+                let attribute_flag: u8 = 0b01000000;
+                let attribute_type: u8 = 3;
+                let attribute_length: u8 = 4;
+                let mut attribute_bytes = ip.octets().to_vec();
+                let mut bytes = vec![attribute_flag, attribute_type, attribute_length];
+                bytes.append(&mut attribute_bytes);
+                bytes
+            }
+            PathAttribute::AtomicAggregate => unimplemented!(),
+            PathAttribute::DontKnow(v) => v.to_vec(),
+        }
     }
----

[source, rust, linenums, title=/src/bgp/peer.rs]
----
diff --git a/mrbgpdv2second/src/bgp/peer.rs b/mrbgpdv2second/src/bgp/peer.rs
index 18c1cd2..621c1bf 100644
--- a/mrbgpdv2second/src/bgp/peer.rs
+++ b/mrbgpdv2second/src/bgp/peer.rs
@@ -88,6 +88,9 @@ impl Peer {
             BgpMessageType::Keepalive => {
                 self.event_queue.enqueue(Event::Keepalive);
             }
+            BgpMessageType::Update => {
+                self.event_queue.enqueue(Event::UpdateMsg);
+            }
         }
         self.message_queue.enqueue(bgp_message);
     }
@@ -216,15 +219,22 @@ impl Peer {
                     unimplemented!();
                 }
                 Event::LocRibChanged => {
+                    debug!("loc rib is {:?}", &self.loc_rib);
                     self.loc_rib.install_route_to_adj_rib_out(
                         &mut self.adj_rib_out,
                         self.config.local_as_number,
                         self.config.local_ip_address,
                     );
+                    self.event_queue.enqueue(Event::AdjRibOutChanged);
                 }
                 Event::AdjRibOutChanged => {
                     // ToDo3: Update Messageをピアに送信する。
-                    unimplemented!();
+                    debug!("adj rib out is {:?}", &self.adj_rib_out);
+                    let update_messages = self.adj_rib_out.to_bgp_update_messages();
+                    self.adj_rib_out.update_all_entries_status_to_unchanged();
+                    for update_message in update_messages {
+                        self.send_bgp_message_to_remote_peer(BgpMessage::Update(update_message));
+                    }
                 }
                 _ => {}
             },
----

[source,rust,linenums,title=src/bgp/rib.rs]
----
diff --git a/mrbgpdv2second/src/bgp/rib.rs b/mrbgpdv2second/src/bgp/rib.rs
index c941ea8..819ee13 100644
--- a/mrbgpdv2second/src/bgp/rib.rs
+++ b/mrbgpdv2second/src/bgp/rib.rs
@@ -1,6 +1,9 @@
+use std::collections::HashMap;
+use std::convert::TryInto;
 use std::net::Ipv4Addr;
 use std::str::FromStr;
 
+use crate::bgp::message::{BgpMessageHeader, BgpMessageType, BgpUpdateMessage};
 use crate::bgp::path_attribute::PathAttribute;
 use crate::bgp::AutonomousSystemNumber;
 use crate::routing::{IpPrefix, RoutingTableEntry};
@@ -8,12 +11,12 @@ use crate::routing::{IpPrefix, RoutingTableEntry};
 pub type LocRib = Rib;
 pub type AdjRibOut = Rib;
 
-#[derive(Clone)]
+#[derive(Clone, Debug)]
 pub struct Rib {
     table: Vec<RibEntry>,
 }
 
-#[derive(Clone)]
+#[derive(Clone, Debug)]
 pub struct RibEntry {
     routing_table_entry: RoutingTableEntry,
     status: RibEntryStatus,
@@ -75,10 +78,53 @@ impl Rib {
             }
         }
 
+        self.update_all_entries_status_to_unchanged();
+        adj_rib_out.insert_table(rib);
+    }
+
+    pub fn update_all_entries_status_to_unchanged(&mut self) {
         self.table
             .iter_mut()
             .for_each(|e| e.status = RibEntryStatus::UnChanged);
-        adj_rib_out.insert_table(rib);
+    }
+
+    fn split_by_path_attribute(&self) -> Vec<Rib> {
+        let mut result = HashMap::new();
+        let mut rib = self.table.clone();
+        for entry in rib {
+            if !result.contains_key(&entry.path_attributes) {
+                result.insert(entry.path_attributes.clone(), vec![entry]);
+            } else {
+                result.get_mut(&entry.path_attributes).unwrap().push(entry);
+            }
+        }
+        result.values().cloned().map(|r| Rib::new(r)).collect()
+    }
+
+    pub fn to_bgp_update_messages(&self) -> Vec<BgpUpdateMessage> {
+        let rib = self.split_by_path_attribute();
+        rib.iter().map(|r| r.to_bgp_update_message()).collect()
+    }
+
+    fn to_bgp_update_message(&self) -> BgpUpdateMessage {
+        let path_attributes = self.table[0].path_attributes.clone();
+        let withdrawn_routes: Vec<IpPrefix> = self
+            .table
+            .iter()
+            .filter(|e| e.status == RibEntryStatus::Withdrawn)
+            .map(|e| e.routing_table_entry.network_address)
+            .collect();
+        let network_layer_reachability_information: Vec<IpPrefix> = self
+            .table
+            .iter()
+            .filter(|e| e.status == RibEntryStatus::Updated)
+            .map(|e| e.routing_table_entry.network_address)
+            .collect();
+        BgpUpdateMessage::new(
----
== 複数ピアをハンドリング可能な実装
=== 本章で作るものの全体像

== 色々完成度を高める
=== 作業の明確化
[ ] タイマーイベントの導入

== 他社実装との疎通確認
