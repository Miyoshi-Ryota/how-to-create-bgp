
:toc:
:source-highlighter: highlightjs
:highlightjs-languages: rust

= 作って学ぶルーティングプロトコル〜RustでBGPを実装〜
Miyoshi Ryota (@llp_qlv / mr-csce (miyoshi))

== はじめに
現在執筆中です。

次の本書のGitHubリポジトリや、本書で作成したBGPデーモンのリポジトリにStarをいただけると嬉しいです。
++++
本書のリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=how-to-create-bgp
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
本書で作成したBGPデーモンのリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=mrbgpd
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
++++

本書ではルーティングプロトコルの1つであるBGP（特に今回はEBGP4）をRustで実装する本です。
読者に以下の前提知識を求めています。

. ルーティングプロトコルは聞いたことがある。
. スタティックルートとは何か分かる。
. ルーティングテーブルを見て意味が分かる。
. 何らかのプログラミング言語でのプログラミング経験

以下の経験があるとよりわかりやすいかもしれません。

. BGPの運用経験

== BGPの実装に必要な知識の学習
=== BGPとは
本章は執筆予定です。すでに良い教材が多く存在するため後回しにしています。
本章が執筆されるまでの参考文献として、2つ紹介します。
BGPについて詳しくない方は、どちらかを読み、本章以降に進んでください。
すべての内容を記憶する必要はありません。
なんとなく見ておくと、本章以降の理解が容易になります。

https://www.infraexpert.com/study/study60.html[ネットワークエンジニアとして - BGPの技術]の次の章が参考になります。

* https://www.infraexpert.com/study/bgpz01.html[BGP（ Border Gateway Protocol ）とは]
* https://www.infraexpert.com/study/bgpz02.html[BGP - 4つのメッセージ、6つのステータスと状態遷移]
* https://www.infraexpert.com/study/bgpz03.html[BGP - IBGPとEBGPの違い]
* https://www.infraexpert.com/study/bgpz04.html[BGP - スタブAS、トランジットAS、非トランジットAS]
* https://www.infraexpert.com/study/bgpz05.html[BGP - パスアトリビュート（ パス属性 ）＆ ベストパス選択]
* https://www.infraexpert.com/study/bgpz06.html[BGP - コンフィグ設定 - 基本設定]

http://www5e.biglobe.ne.jp/aji/30min/index.html[30分間ネットワーキング]の次の章が参考になります。

* http://www5e.biglobe.ne.jp/aji/30min/16.html[第16回 BGP4(1) AS]
* http://www5e.biglobe.ne.jp/aji/30min/17.html[第17回 BGP4(2) BGPピア]
* http://www5e.biglobe.ne.jp/aji/30min/18.html[第18回 BGP4(3) IBGPとEBGP]
* http://www5e.biglobe.ne.jp/aji/30min/19.html[第19回 BGP4(4) パスアトリビュート]
* http://www5e.biglobe.ne.jp/aji/30min/20.html[第20回 BGP4(5) ベストパス選択]

=== BGPはイベント駆動ステートマシン
=== イベント駆動ステートマシンとは [[what_is_event_driven_state_machine]]
イベント駆動ステートマシンとは、現在の状態（ステート）と入力（イベント）によって動作が決定するモノのモデルです。

例として、テレビをステートマシンとして表現します。
テレビの状態として、1. 電源ON、2. 電源OFFの2状態が存在し、入力としてa. 電源ボタンの押下、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下の3つが存在するとします。本来のテレビはもっと多数の状態やイベントを持っていますが、ここでは例示のためにシンプルにしています。

テレビの状態が1. 電源OFFのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源ONに遷移します。テレビの状態が1. 電源OFFのときに、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合はテレビの状態は1. 電源OFFのままで何も起こりません。

テレビの状態が2. 電源ONのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源OFFに遷移します。テレビの状態が2. 電源ONのときb. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合は、テレビの状態は2. 電源ONのまま音量が増減します。

このように現在の状態と、入力によって動作が決定するモノとして表現することが可能です。これを図示すると次のようになります。

[plantuml]
----
@startuml

state 電源OFF

state 電源ON

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----

本書ではステートマシン図では表しにくい動作の内容について、次のように付箋をつけることにします。
この図では、状態が電源ONのときに、音量増加ボタンの押下が入力されたときには、状態を電源ONのままにするだけでなく、音量を増加させることを表しています。

[plantuml]
----
@startuml

state 電源OFF

state 電源ON

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
note on link
   音量の増加
end note
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----

=== イベント駆動ステートマシンの例
イベント駆動ステートマシンをどのよう実装すればいいのかという勘所を掴んでもらうために<<what_is_event_driven_state_machine>>の章で例示したテレビをコードにします。
次のようになります。

[source,rust]
----
use rand::Rng;
use std::collections::VecDeque;
use std::thread;
use std::time::Duration;

#[derive(Debug)]
enum State {
    PowerOn,
    PowerOff,
}

#[derive(Debug)]
enum Event {
    PushedPowerButton,
    PushedVolumeIncreaseButton,
    PushedVolumeDecreaseButton,
}

struct TV {
    now_state: State,
    event_queue: EventQueue,
    volume: u8,
}

impl TV {
    pub fn new() -> Self {
        let now_state = State::PowerOff;
        let event_queue = EventQueue::new();
        let volume = 10;
        Self {
            now_state,
            event_queue,
            volume,
        }
    }

    pub fn be_pushed_power_button(&mut self) {
        self.event_queue.enqueue(Event::PushedPowerButton);
    }

    pub fn be_pushed_volume_increase_button(&mut self) {
        self.event_queue.enqueue(Event::PushedVolumeIncreaseButton);
    }

    pub fn be_pushed_volume_decrease_button(&mut self) {
        self.event_queue.enqueue(Event::PushedVolumeDecreaseButton);
    }

    pub fn handle_event(&mut self, event: Event) {
        match &self.now_state {
            &State::PowerOn => match event {
                Event::PushedPowerButton => {
                    self.now_state = State::PowerOff;
                }
                Event::PushedVolumeIncreaseButton => {
                    self.volume += 1;
                }
                Event::PushedVolumeDecreaseButton => {
                    self.volume -= 1;
                }
            },
            &State::PowerOff => match event {
                Event::PushedPowerButton => {
                    self.now_state = State::PowerOn;
                }
                _ => (),
            },
        }
    }
}

struct EventQueue(VecDeque<Event>);

impl EventQueue {
    pub fn new() -> Self {
        let d = VecDeque::new();
        EventQueue(d)
    }

    pub fn dequeue(&mut self) -> Option<Event> {
        self.0.pop_front()
    }

    pub fn enqueue(&mut self, event: Event) {
        self.0.push_back(event);
    }
}

fn push_random_button_of_tv(tv: &mut TV) {
    let mut rng = rand::thread_rng();
    match rng.gen_range(0..4) {
        1 => tv.be_pushed_power_button(),
        2 => tv.be_pushed_volume_increase_button(),
        3 => tv.be_pushed_volume_decrease_button(),
        _ => (),
    };
}

fn main() {
    let mut tv = TV::new();
    tv.be_pushed_power_button();
    loop {
        push_random_button_of_tv(&mut tv);
        if let Some(event) = tv.event_queue.dequeue() {
            println!(
                "tv information: {{ now_state={:?}, volume={} }}, input_event: {:?}",
                tv.now_state, tv.volume, event
            );
            tv.handle_event(event);
        }
        thread::sleep(Duration::from_secs(2));
    }
}
----

実行時のログです。

[source, shell]
----
mrcsce@pop-os:~/programming/rustProjects/samplecode$ cargo run
   Compiling samplecode v0.1.0 (/home/mrcsce/programming/rustProjects/samplecode)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33s
     Running `target/debug/samplecode`
tv information: { now_state=PowerOff, volume=10 }, input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=10 }, input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOn, volume=9 }, input_event: PushedPowerButton
tv information: { now_state=PowerOff, volume=9 }, input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=9 }, input_event: PushedPowerButton
tv information: { now_state=PowerOff, volume=9 }, input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=9 }, input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=10 }, input_event: PushedPowerButton
tv information: { now_state=PowerOff, volume=10 }, input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOff, volume=10 }, input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOff, volume=10 }, input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOff, volume=10 }, input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=10 }, input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }, input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=12 }, input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=13 }, input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=14 }, input_event: PushedPowerButton
tv information: { now_state=PowerOff, volume=14 }, input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOff, volume=14 }, input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOff, volume=14 }, input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOff, volume=14 }, input_event: PushedVolumeIncreaseButton
^C
mrcsce@pop-os:~/programming/rustProjects/samplecode$ 
----

== 1つのピアを実装するまで
=== main関数の実装
=== 本章で作るものの全体像
[plantuml]
----
@startuml
class Animal {
  run()
}

class Cat extends Animal {
}
@enduml
----


== 複数ピアをハンドリング可能な実装
=== 本章で作るものの全体像

== 他社実装との疎通確認
