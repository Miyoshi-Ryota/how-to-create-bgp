:toc:
:source-highlighter: pygments
:prewrap!:


= 作って学ぶルーティングプロトコル〜RustでBGPを実装〜
Miyoshi Ryota (@llp_qlv / mr-csce (miyoshi))

== はじめに
現在執筆中です。
なお本書の一部はChrome / Firefoxでしか動作しません。
Safari / IE / Edgeでは動作しません。

次の本書のGitHubリポジトリや、本書で作成したBGPデーモンのリポジトリにStarをいただけると嬉しいです。
++++
本書のリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=how-to-create-bgp
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
本書で作成したBGPデーモンのリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=mrbgpdv2
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
++++

本書ではルーティングプロトコルの1つであるBGP（特に今回はEBGP4）をRustで実装する本です。
読者に以下の前提知識を求めています。

. ルーティングプロトコルは聞いたことがある。
. スタティックルートとは何か分かる。
. ルーティングテーブルを見て意味が分かる。
. 何らかのプログラミング言語でのプログラミング経験

以下の経験があるとよりわかりやすいかもしれません。

. BGPの運用経験

=== 執筆環境
筆者は以下の環境で作成・動作確認しています。

* Ubuntu 20.04 LTS / Pop!_OS 20.04 LTS
* cargo 1.53.0-nightly (f3e13226d 2021-04-30)
* rustc 1.54.0-nightly (676ee1472 2021-05-06)

おそらくほとんど全てのLinux Distribution、MacOSでも動作するものと考えていますが、確認・テストはしていません。
RustのVersionについても同様にテストしていませんが、
ある程度新しければ動作すると考えています。

== BGPの実装に必要な知識の学習
=== BGPとは
本章は執筆予定です。すでに良い教材が多く存在するため後回しにしています。
本章が執筆されるまでの参考文献として、2つ紹介します。
BGPについて詳しくない方は、どちらかを読み、本章以降に進んでください。
すべての内容を記憶する必要はありません。
なんとなく見ておくと、本章以降の理解が容易になります。

https://www.infraexpert.com/study/study60.html[ネットワークエンジニアとして - BGPの技術]の次の章が参考になります。

* https://www.infraexpert.com/study/bgpz01.html[BGP（ Border Gateway Protocol ）とは]
* https://www.infraexpert.com/study/bgpz02.html[BGP - 4つのメッセージ、6つのステータスと状態遷移]
* https://www.infraexpert.com/study/bgpz03.html[BGP - IBGPとEBGPの違い]
* https://www.infraexpert.com/study/bgpz04.html[BGP - スタブAS、トランジットAS、非トランジットAS]
* https://www.infraexpert.com/study/bgpz05.html[BGP - パスアトリビュート（ パス属性 ）＆ ベストパス選択]
* https://www.infraexpert.com/study/bgpz06.html[BGP - コンフィグ設定 - 基本設定]

http://www5e.biglobe.ne.jp/aji/30min/index.html[30分間ネットワーキング]の次の章が参考になります。

* http://www5e.biglobe.ne.jp/aji/30min/16.html[第16回 BGP4(1) AS]
* http://www5e.biglobe.ne.jp/aji/30min/17.html[第17回 BGP4(2) BGPピア]
* http://www5e.biglobe.ne.jp/aji/30min/18.html[第18回 BGP4(3) IBGPとEBGP]
* http://www5e.biglobe.ne.jp/aji/30min/19.html[第19回 BGP4(4) パスアトリビュート]
* http://www5e.biglobe.ne.jp/aji/30min/20.html[第20回 BGP4(5) ベストパス選択]

=== BGPはイベント駆動ステートマシン
=== イベント駆動ステートマシンとは [[what_is_event_driven_state_machine]]
イベント駆動ステートマシンとは、現在の状態（ステート）と入力（イベント）によって動作が決定するモノのモデルです。

例として、テレビをステートマシンとして表現します。
テレビの状態として、1. 電源ON、2. 電源OFFの2状態が存在し、入力としてa. 電源ボタンの押下、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下の3つが存在するとします。本来のテレビはもっと多数の状態やイベントを持っていますが、ここでは例示のためにシンプルにしています。

テレビの状態が1. 電源OFFのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源ONに遷移します。テレビの状態が1. 電源OFFのときに、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合はテレビの状態は1. 電源OFFのままで何も起こりません。

テレビの状態が2. 電源ONのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源OFFに遷移します。テレビの状態が2. 電源ONのときb. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合は、テレビの状態は2. 電源ONのまま音量が増減します。

このように現在の状態と、入力によって動作が決定するモノとして表現することが可能です。これを図示すると<<example_state_machine_diagram>>になります。

[[example_state_machine_diagram]]
[plantuml,title=テレビのステートマシン図]
----
@startuml

state 電源OFF

state 電源ON

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----

本書ではステートマシン図では表しにくい動作の内容について、<<example_state_machine_diagram_2>>のように付箋をつけることにします。
この図では、状態が電源ONのときに、音量増加ボタンの押下が入力されたときには、状態を電源ONのままにするだけでなく、音量を増加させることを表しています。

[[example_state_machine_diagram_2]]
[plantuml,title=テレビのイベント駆動ステートマシンとしての表現（本書の記法）]
----
@startuml

state 電源OFF

state 電源ON

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
note on link
   音量の増加
end note
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----

=== イベント駆動ステートマシンの例
イベント駆動ステートマシンをどのよう実装すればいいのかという勘所を掴んでもらうために<<what_is_event_driven_state_machine>>の章で例示したテレビをコードにします。
次のようになります。

[[example_of_state_machine_impl]]
[source,rust,linenums,title="イベント駆動ステートマシンの例（テレビ）"]
----
use rand::Rng;
use std::collections::VecDeque;
use std::thread;
use std::time::Duration;

#[derive(Debug)]
enum State {
    PowerOn,
    PowerOff,
}

#[derive(Debug)]
enum Event {
    PushedPowerButton,
    PushedVolumeIncreaseButton,
    PushedVolumeDecreaseButton,
}

struct TV {
    now_state: State,
    event_queue: EventQueue,
    volume: u8,
}

impl TV {
    pub fn new() -> Self {
        let now_state = State::PowerOff;
        let event_queue = EventQueue::new();
        let volume = 10;
        Self {
            now_state,
            event_queue,
            volume,
        }
    }

    pub fn be_pushed_power_button(&mut self) {
        self.event_queue.enqueue(Event::PushedPowerButton);
    }

    pub fn be_pushed_volume_increase_button(&mut self) {
        self.event_queue.enqueue(Event::PushedVolumeIncreaseButton);
    }

    pub fn be_pushed_volume_decrease_button(&mut self) {
        self.event_queue.enqueue(Event::PushedVolumeDecreaseButton);
    }

    pub fn handle_event(&mut self, event: Event) {
        match &self.now_state {
            &State::PowerOn => match event {
                Event::PushedPowerButton => {
                    self.now_state = State::PowerOff;
                }
                Event::PushedVolumeIncreaseButton => {
                    self.volume += 1;
                }
                Event::PushedVolumeDecreaseButton => {
                    self.volume -= 1;
                }
            },
            &State::PowerOff => match event {
                Event::PushedPowerButton => {
                    self.now_state = State::PowerOn;
                }
                _ => (),
            },
        }
    }
}

struct EventQueue(VecDeque<Event>);

impl EventQueue {
    pub fn new() -> Self {
        let d = VecDeque::new();
        EventQueue(d)
    }

    pub fn dequeue(&mut self) -> Option<Event> {
        self.0.pop_front()
    }

    pub fn enqueue(&mut self, event: Event) {
        self.0.push_back(event);
    }
}

fn push_random_button_of_tv(tv: &mut TV) {
    let mut rng = rand::thread_rng();
    match rng.gen_range(0..4) {
        1 => tv.be_pushed_power_button(),
        2 => tv.be_pushed_volume_increase_button(),
        3 => tv.be_pushed_volume_decrease_button(),
        _ => (),
    };
}

fn main() {
    let mut tv = TV::new();
    tv.be_pushed_power_button();
    loop {
        push_random_button_of_tv(&mut tv);
        if let Some(event) = tv.event_queue.dequeue() {
            println!(
                "tv information: {{ now_state={:?}, volume={} }}\ninput_event: {:?}",
                tv.now_state, tv.volume, event
            );
            tv.handle_event(event);
        }
        thread::sleep(Duration::from_secs(2));
    }
}
----

103行目でTVのランダムなボタンを押下し、TVにイベント（入力）を送信しています。送信されたEventはイベントキュー、tv.event_queueにエンキューします。
104でイベントキューに保存されているイベント（入力）を取り出します。
TVの現在の状態（State）はTVのインスタンスに保存されています。
109行目でイベント（入力）を扱います。
49行目〜69行目を見ると分かるように、`tv.handle_event(event)`はeventとtvインスタンスに保存されている現在の状態に応じて、動作し次の状態を決定します。
それはイベント駆動ステートマシン、そのものでした。このようにしてイベント駆動ステートマシンを実装することができました。

次が<<log_of_sample_state_machine>>です。

ログの4行目を見ると、電源OFFの状態であることがわかります。
次にログの5行目を見ると、電源ボタンが押されたことがわかります。
次にログの6行目を見ると、電源ONの状態に遷移したことがわかります。
次にログの7行目を見ると、音量増加ボタンが押されたことがわかります。
次にログの8行目を見ると、電源ON状態のまま、音量が11に増加していることがわかります。

一方でログの16、17、18行目を見ると、電源OFF状態のときに音量増加ボタンが押されても、電源OFF状態のままで音量の変動もないことがわかります。

[[log_of_sample_state_machine]]
[source,html,linenums,title="実行時のログ"]
----
mrcsce@pop-os:~/programming/rustProjects/samplecode$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/samplecode`
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeIncreaseButton
^C
mrcsce@pop-os:~/programming/rustProjects/samplecode$
----


これは<<what_is_event_driven_state_machine>>の章で例示した通りの動作です。
例示したイベント駆動ステートマシンを実装できていることが確かめられました。
BGPのステートマシンも前述の<<example_of_state_machine_impl>>に似た方針で実装していきます。

== 1つのピアを実装するまで
=== BGPはどんなイベント駆動ステートマシンなのか
BGPはどのようなイベント駆動ステートマシンとして表すのが良いでしょうか。

実は https://tools.ietf.org/html/rfc4271[RFC4271-A Border Gateway Protocol 4 (BGP-4)]の https://tools.ietf.org/html/rfc4271#section-8[8.  BGP Finite State Machine (FSM)]に、イベント駆動ステートマシンの定義の記載があります。

しかし最初から https://tools.ietf.org/html/rfc4271#section-8[8.  BGP Finite State Machine (FSM)]を参照して、完全なBGPを作成することは大変です。
そのため本書ではBGPを次の段階に分けて開発します。

1. まずは1つのピアがEstablishedに遷移可能
2. 1つのピアでUpdate Messageの交換やUpdate Messageの内容にしたがってRouting Tableへの書き込みが可能
3. 複数のピアを扱うことが可能
4. 細かい完成度を増加

本章のコードは GitHubの https://github.com/Miyoshi-Ryota/mrbgpdv2[本書のリポジトリ]にすべて公開しています。
本書中にすべてのコードを乗せるつもりですが、断片のコードではなくすべてのコードを一気に閲覧したい方はリポジトリを参照してください。
また本章の第一段階「<<first_rev>>」のコードは同リポジトリの https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/main/mrbgpdv2first[同リポジトリのmrbgpdv2first/] に存在します。


=== 1つのピアがEstablishedに遷移するところまでの実装 [[first_rev]]
まずは1つのピアがEstablishedに至るまでの正常系のみのイベント駆動ステートマシンを実装します。

RFCの方針の通り、1つのBGPピアを1つのイベント駆動ステートマシンとして表します。
BGPのイベント駆動ステートマシンの状態もIdle, Connect, OpenConfirm, OpenSent, Establishedの5つ用意します。
この状態は、 https://www.infraexpert.com/study/bgpz02.html[BGP - 4つのメッセージ、6つのステータスと状態遷移] で説明しているBGPの6つの状態のうちActiveを除いたものと対応しています。Activeは非正常系パスでしか遷移しない状態のため、第一段階では除いています。

第一段階のイベントとして次の5個を使用します。イベントの名前と定義はRFCにしたがってしています。

[cols=2*, title=BGPのイベント駆動ステートマシンのイベント]
|===
| イベント名 | 定義
| ManualStart | システムの管理者が手動でピアのコネクションをスタートさせた際のイベント
| Tcp_CR_Acked| TCPコネクションのリクエストを確立させた際のイベント。言い換えれば、システムがTCP SYNを送信し、TCP SYN/ACKを受信し、TCP ACKを送信したときのイベント。
| TcpConnectionConfirmed | TCPコネクションが確立された際のイベント。言い換えれば、対向先からTCP SYNを受け取り、システムがTCP SYN/ACKを送信し、TCP ACKを受信したときのイベント
| BGPOpen | 正常なOpen Messageを受信したときのイベント
| KeepAliveMsg | Keepalive Messageを受信したときのイベント
|===


以下に<<first_impl_bgp>>を図示します。図中の黒丸はステートマシンの初期状態を表しています。図示していない（想定していない）遷移が発生した場合はすべてクラッシュすることにします。例えば、Connect状態で、BGP Open eventが発生した場合はクラッシュすることにします。

[[first_impl_bgp]]
[plantuml,title="第一段階で実装するステートマシン"]
----
@startuml

state Idle
state Connect
state OpenConfirm
state OpenSent
state Established

[*] --> Idle
Idle --> Connect : ManualStart event
note on link
   対向側機器とTCPコネクションを作成を試みる。
end note
Connect --> OpenSent : Tcp_CR_Acked | TcpConnectionConfirmed event
note on link
   対向側機器にBGP OpenMessageを送信する。
end note
OpenSent --> OpenConfirm : BGPOpen event
note on link
    対向機器にBGP Keepalive Messageを送信する。
end note
OpenConfirm --> Established : KeepAliveMsg event

@enduml
----

==== 作業の明確化
ここまででなんとなく作るものが見えてきたでしょうか。本章では、<<first_rev>>をToDoレベルに明確化します。

[title=タスクリスト]
* [ ] プロジェクトを作成する
* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


==== プロジェクトの作成

Rustは以下のコマンドで新しいプロジェクトを作成することが出来ます。
[source]
----
cargo new <プロジェクトの名前>
----

[title=タスクリスト]
* [x] プロジェクトを作成する
* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


==== Connect Stateに遷移する
それでは中身に入っていきましょう。
下記に取り組みます。

* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる

BGPは1つのピアが1つのイベント駆動ステートマシンとして表せます。
ピアに関するソースコードは./src/bgp/peer.rsに書くことにしましょう。

 ./src/bgp/peer.rsを追加するとディレクトリ構造は下記のようになります。

[source]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── bgp
│   │   ├── mod.rs
│   │   └── peer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title="./lib.rs]
----
pub mod bgp;
----

[source,rust,linenums,title="./bgp/mod.rs]
----
pub mod peer;
----

[source,rust,linenums,title="./bgp/peer.rs]
----
// 空ファイルです
----

まずテストを書きましょう。
Connectに遷移するまでの過程は<<bgp_first_test, 次>>のようにしてみましょう。

[[bgp_first_test]]
[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/connect-state-made/mrbgpdv2first/src/bgp/peer.rs[lines=58..69]
----

bgp_peer.start()でピアのコネクションを開始（ManualStartイベントを発火）させ、bgp_peer.next_step()で、そのピアのイベントキューからイベントを1つ取り出しハンドリングするつもりのコードです。

実はConnect Stateに遷移するところまででは、Configは不要です。しかしこの後、すぐに使用するので、この段階で合わせて実装しています。


このテストが通るまでコンパイラのエラーにしたがってコードを追加していくと下記のようになります。

[source,title="ディレクトリ構造"]
----
├── src
│   ├── bgp
│   │   ├── config.rs
│   │   ├── event_queue.rs
│   │   ├── mod.rs
│   │   └── peer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title="src/bgp/mod.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/mod.rs[]
----


[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/peer.rs[]
----

[source,rust,linenums,title="src/bgp/event_queue.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/event_queue.rs[]
----

[source,rust,linenums,title="src/bgp/config.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/config.rs[]
----


それではテストを実行し、OKになることを確認しましょう。
[source]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cargo test
   Compiling mrbgpdv2first v0.1.0 (/home/mrcsce/programming/rustProjects/mrbgpdv2/mrbgpdv2first)
    Finished test [unoptimized + debuginfo] target(s) in 0.48s
     Running unittests (target/debug/deps/mrbgpdv2first-773462fadd3e9533)

running 1 tests
test bgp::peer::tests::peer_can_transition_to_connect_start ... ok
----

これでまた1つタスクが完了しました。

[title=タスクリスト]
* [x] プロジェクトを作成する
* [x] Connect Stateに遷移する
    - [x] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


==== OpenSent Stateに遷移する
次に下記に取り組みます。

* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する

まずはテストを書きます。
threadを使用して擬似的にリモート側のコンピュータを表しています。

[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/peer.rs[lines=90..91;93..94;105..128]
----

このテストが通れば、上記のタスクは完了したと言えます。
以下のようなコードの更新でテストを通すことが可能です。

* handle_eventにcreate_tcp_connection_to_remote_ipが増えている。
* create_tcp_connection_to_remote_ipでリモートとコネクションを張っている。
* コネクションがはれたらその旨を知らせるイベントをenqueueしている
* そのイベントをhandle_eventして状態を遷移している

++++
 <script type="module" src="https://unpkg.com/x-frame-bypass"></script>
<iframe is="x-frame-bypass" src="https://github.com/Miyoshi-Ryota/mrbgpdv2/compare/4028dd5957849b2ed4b3d7432f56667125163f92...f133fc092a43103322ceadb4b40d9d9f28952548" onload='javascript:(function(o){o.style.height=o.contentWindow.document.body.scrollHeight+"px";}(this));' style="height:200px;width:100%;border:none;overflow:hidden;" frameborder="0" title="GitHub"></iframe>
++++


本コードでは`create_tcp_connection_to_remote_ip`メソッドでバインドしています。
これはroot権限が必要な操作です。
root権限でテストを実行可能にする必要があります。
cargoのコンフィグファイルにrunner = 'sudo -E'と指定することで
root権限でテストを実行してくれます。

[source,title=~/.cargo/config]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cat ~/.cargo/config 

# nightly-x86_64-unknown-linux-gnu
[target.x86_64-unknown-linux-gnu]
runner = 'sudo -E'
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ 
----


テストを走らせてみましょう。
下記が結果です。無事にテストが通っていることが確認できました。
[source, title=テスト結果]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cargo test 
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests (target/debug/deps/mrbgpdv2first-773462fadd3e9533)

running 2 tests
test bgp::peer::tests::peer_can_transition_to_connect_start ... ok
test bgp::peer::tests::peer_can_transition_to_open_sent_start ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.50s

     Running unittests (target/debug/deps/mrbgpdv2first-eb97df666ba678c7)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests mrbgpdv2first

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ 
----

これで、またタスクが一つ完了しました。

* [x] プロジェクトを作成する
* [x] Connect Stateに遷移する
    - [x] ManualStart Eventを発生させる
* [x] OpenSent Stateに遷移する
    - [x] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


現段階の全体のコードを記載します。GitHub上で閲覧したい方は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first[GitHub-現段階の全体のコード]を参照してください。

[source,rust,linenums,title="src/bgp/mod.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/mod.rs[]
----


[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/peer.rs[]
----

[source,rust,linenums,title="src/bgp/event_queue.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/event_queue.rs[]
----

[source,rust,linenums,title="src/bgp/config.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/config.rs[]
----


==== OpenConfirm Stateに遷移する
次は下記に取り組みましょう。

* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する

まず、テストを書きます。
ここからは通信が発生するため、正確に何度.next_step()を呼んだときにお目当ての状態に遷移するのかわかりません。
そのため、50回以内に想定のステータスに遷移することでテストOKとしています。
また複数のテストケースで同じソケットアドレスにbindします。複数のテストが同時に動き、同時に複数回同じソケットアドレスにbindすることを防ぐために、テストは1つづつ実行することとします。また、ここからは少しずつ複雑になるためロガーも仕込んでいます。
そのためテストを走らせるときは次のようなコマンドを使用します。

----
RUST_LOG=info cargo test -- --nocapture --test-threads=1
----

[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/peer.rs[lines=198..201;237..274]
----

このテストが通れば、上記のタスクは完了したと言えます。

以下のようなコードの更新でテストを通すことが可能です。
差分をGitHubで閲覧したい方は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/compare/f133fc092a43103322ceadb4b40d9d9f28952548...87771a19f2f90e16546a4603a235cb9f02b4313d[GitHub上の差分]を閲覧してください。

* OpenMessageを送信するところを説明する。
    * Peerのnext_step()にsend_bgp_messageが生えていること
    * OpenMessageはhogeのように書くことが出来ること
    * BGPメッセージはどんな構造になっているのか
    * OpenMessageはどんな構造をしているのか
    * src/bgp/message.rsの内容
* OpenMessageを受信するところを説明する。
    * non_blocking modeに変更していること
    * next_stepにrecive_one_message()を入れていること
    * handle_bgp_messageでハンドルしてイベントを注入していること
    * recieve_one_messageの説明
        * transfer_data_tcp-connection_to_self_bufferは、該当のコネクションで受信したデータをすべてself.bufferに移している
        * retrive_one_message_from_bufferはself.bufferから1つのBGPメッセージのバイト列を取得している。
        * そのバイト列をモデルに変換している

[source,rust,linenums,title=Cargo.toml]
----
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
+log = "0.4.0"
+ env_logger = "0.8.3"
----

[source,rust,linenums,title=src/bgp/config.rs]
----
 use crate::bgp;
 use std::{net::Ipv4Addr, str::FromStr};
 pub struct Config {
-    local_as_number: bgp::AutonomousSystemNumber,
+    pub local_as_number: bgp::AutonomousSystemNumber,
     pub local_ip_address: Ipv4Addr,
     remote_as_number: bgp::AutonomousSystemNumber,
     pub remote_ip_address: Ipv4Addr,
deleted file mode 100644
+++ /dev/null
-use crate::bgp::peer::Event;
-use std::collections::VecDeque;
-
-pub struct EventQueue(VecDeque<Event>);
-
-impl EventQueue {
-    pub fn new() -> Self {
-        EventQueue(VecDeque::new())
-    }
-
-    pub fn enqueue(&mut self, event: Event) {
-        self.0.push_front(event);
-    }
-
-    pub fn dequeue(&mut self) -> Option<Event> {
-        self.0.pop_back()
-    }
-}
----

[source,rust,linenums,title=src/bgp/message.rs]
----
+use super::timer::HoldTime;
+use super::AutonomousSystemNumber;
+use std::{convert::TryInto, net::Ipv4Addr};
+
+#[derive(Debug)]
+pub enum BgpMessage {
+    Open(BgpOpenMessage),
+}
+impl BgpMessage {
+    pub fn serialize(&self) -> Vec<u8> {
+        match self {
+            BgpMessage::Open(open) => open.serialize(),
+            _ => panic!(),
+        }
+    }
+
+    pub fn deserialize(bytes: &Vec<u8>) -> Self {
+        let bgp_type = BgpMessageType::from_type_number(bytes[18]);
+        match bgp_type {
+            BgpMessageType::Open => BgpMessage::Open(BgpOpenMessage::deserialize(bytes)),
+        }
+    }
+
+    pub fn get_type(&self) -> BgpMessageType {
+        match self {
+            BgpMessage::Open(_) => BgpMessageType::Open,
+        }
+    }
+}
+
+#[derive(Debug)]
+pub struct BgpMessageHeader {
+    pub length: u16,
+    pub type_: BgpMessageType,
+}
+
+impl BgpMessageHeader {
+    fn serialize(&self) -> Vec<u8> {
+        let marker = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
+        let length = self.length.to_be_bytes();
+        let type_ = self.type_.to_type_number();
+        let mut bytes = vec![];
+        bytes.append(&mut marker.to_vec());
+        bytes.append(&mut length.to_vec());
+        bytes.push(type_);
+        bytes
+    }
+
+    pub fn deserialize(bytes: &Vec<u8>) -> Self {
+        let length = u16::from_be_bytes(bytes[16..18].try_into().unwrap());
+        let type_ = BgpMessageType::from_type_number(bytes[18]);
+        Self { length, type_ }
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+pub enum BgpMessageType {
+    Open,
+}
+
+impl BgpMessageType {
+    fn to_type_number(&self) -> u8 {
+        match self {
+            BgpMessageType::Open => 1,
+        }
+    }
+
+    fn from_type_number(type_number: u8) -> Self {
+        match type_number {
+            1 => BgpMessageType::Open,
+            _ => panic!(),
+        }
+    }
+}
+
+#[derive(Debug)]
+struct BgpVersion(u8);
+
+#[derive(Debug)]
+pub struct BgpOpenMessage {
+    header: BgpMessageHeader,
+    version: BgpVersion,
+    my_autonomous_system_number: AutonomousSystemNumber,
+    hold_time: HoldTime,
+    bgp_identifier: Ipv4Addr,
+    optional_parameter_length: u8,
+    // optional_parameterは実装・使用しないが、
+    // 相手から受信したときに一応保存しておくためにプロパティとして用意している。
+    optional_parameters: Vec<u8>,
+}
+
+impl BgpOpenMessage {
+    pub fn new(my_as_number: AutonomousSystemNumber, my_ip_addr: Ipv4Addr) -> Self {
+        let header = BgpMessageHeader {
+            length: 29,
+            type_: BgpMessageType::Open,
+        };
+        let version = BgpVersion(4);
+        let my_autonomous_system_number = my_as_number;
+        let hold_time = HoldTime(240);
+        let bgp_identifier = my_ip_addr;
+        let optional_parameter_length = 0;
+        let optional_parameters = vec![];
+        Self {
+            header,
+            version,
+            my_autonomous_system_number,
+            hold_time,
+            bgp_identifier,
+            optional_parameter_length,
+            optional_parameters,
+        }
+    }
+}
+
+impl BgpOpenMessage {
+    fn serialize(&self) -> Vec<u8> {
+        let mut bytes = vec![];
+        bytes.append(&mut self.header.serialize());
+        bytes.push(self.version.0);
+        bytes.append(&mut self.my_autonomous_system_number.0.to_be_bytes().to_vec());
+        bytes.append(&mut self.hold_time.0.to_be_bytes().to_vec());
+        bytes.append(&mut self.bgp_identifier.octets().to_vec());
+        bytes.push(self.optional_parameter_length);
+        bytes.append(&mut self.optional_parameters.clone());
+        bytes
+    }
+
+    fn deserialize(bytes: &Vec<u8>) -> Self {
+        let header = BgpMessageHeader::deserialize(&bytes[0..19].to_vec());
+        let version = BgpVersion(bytes[19]);
+        let my_autonomous_system_number =
+            AutonomousSystemNumber(u16::from_be_bytes(bytes[20..22].try_into().unwrap()));
+        let hold_time = HoldTime(u16::from_be_bytes(bytes[22..24].try_into().unwrap()));
+        let bgp_identifier: Ipv4Addr = Ipv4Addr::new(bytes[24], bytes[25], bytes[26], bytes[27]);
+        let optional_parameter_length = bytes[28];
+        let optional_parameters = bytes[29..].to_vec();
+
+        Self {
+            header,
+            version,
+            my_autonomous_system_number,
+            hold_time,
+            bgp_identifier,
+            optional_parameter_length,
+            optional_parameters,
+        }
+    }
+}
----

[source,rust,linenums,title=src/bgp/mod.rs]
----
-mod config;
-mod event_queue;
+pub mod config;
+mod message;
 pub mod peer;
+mod queue;
+mod timer;
 
-struct AutonomousSystemNumber(u16);
+#[derive(Debug, Copy, Clone)]
+pub struct AutonomousSystemNumber(u16);
----

[source,rust,linenums,title=src/bgp/peer.rs]
----
-use super::event_queue::EventQueue;
+use super::{
+    message::BgpOpenMessage,
+    queue::{EventQueue, MessageQueue},
+};
 use crate::bgp::config::Config;
 use crate::bgp::config::Mode;
-use std::net::{TcpListener, TcpStream};
+use crate::bgp::message::{BgpMessage, BgpMessageHeader, BgpMessageType};
+use std::{
+    io::{self, Read, Write},
+    net::{TcpListener, TcpStream},
+};
 
-struct Peer {
+pub struct Peer {
     config: Config,
     event_queue: EventQueue,
+    message_queue: MessageQueue,
     now_state: State,
     tcp_connection: Option<TcpStream>,
+    buffer: Vec<u8>,
 }
 
 impl Peer {
     pub fn new(config: Config) -> Self {
         let event_queue = EventQueue::new();
+        let message_queue = MessageQueue::new();
         let now_state = State::Idle;
         let tcp_connection = None;
+        let buffer = vec![];
         Self {
             config,
             event_queue,
+            message_queue,
             now_state,
             tcp_connection,
+            buffer,
         }
     }
 
     }
 
     pub fn next_step(&mut self) {
+        if let Some(bgp_message) = self.recieve_one_message() {
+            info!("Recive bgp message {:?}", bgp_message);
+            self.handle_bgp_message(bgp_message)
+        }
+
         if let Some(event) = self.event_queue.dequeue() {
+            debug!("Now state {:?}, handling event {:?}", self.now_state, event);
             self.handle_event(event);
         }
     }
 
+    fn transfer_data_tcp_connection_to_self_buffer(&mut self) {
+        let mut buffer = vec![];
+        if self.tcp_connection.is_some() {
+            match self
+                .tcp_connection
+                .as_ref()
+                .unwrap()
+                .read_to_end(&mut buffer)
+            {
+                Ok(_) => (), // Tcp ConnectionがCloseしているときにOk()が返ってくる。
+                Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
+                    self.buffer.append(&mut buffer)
+                }
+                Err(e) => error!("{:?}", e),
+            }
+        }
+    }
+
+    fn handle_bgp_message(&mut self, bgp_message: BgpMessage) {
+        match bgp_message.get_type() {
+            BgpMessageType::Open => {
+                self.event_queue.enqueue(Event::BgpOpen);
+            }
+            _ => {}
+        }
+        self.message_queue.enqueue(bgp_message);
+    }
+
+    fn retrive_one_message_from_buffer(&mut self) -> Option<Vec<u8>> {
+        let minimum_length_of_bgp_message = 19;
+        if self.buffer.len() >= minimum_length_of_bgp_message {
+            let bgp_message_header = BgpMessageHeader::deserialize(&self.buffer[0..19].to_vec());
+            let bgp_message_length: u16 = bgp_message_header.length;
+            let (bgp_message_bytes, buf) = self.buffer.split_at(bgp_message_length as usize);
+            let bgp_message_bytes = bgp_message_bytes.to_vec();
+            self.buffer = buf.to_vec();
+            Some(bgp_message_bytes)
+        } else {
+            None
+        }
+    }
+
+    fn recieve_one_message(&mut self) -> Option<BgpMessage> {
+        self.transfer_data_tcp_connection_to_self_buffer();
+        if let Some(bgp_message_byte) = self.retrive_one_message_from_buffer() {
+            Some(BgpMessage::deserialize(&bgp_message_byte))
+        } else {
+            None
+        }
+    }
+
     fn create_tcp_connection_to_remote_ip(&mut self) -> Option<TcpStream> {
         let remote_addr = self.config.remote_ip_address;
         let bgp_port = 179;
             let tcp_connection = TcpStream::connect((remote_addr, bgp_port)).ok();
             if tcp_connection.is_some() {
                 self.event_queue.enqueue(Event::TcpCrAcked);
+                tcp_connection
+                    .as_ref()
+                    .unwrap()
+                    .set_nonblocking(true)
+                    .unwrap();
             };
             tcp_connection
         } else {
             let tcp_connection = tcp_listener.accept().map(|v| v.0).ok();
             if tcp_connection.is_some() {
                 self.event_queue.enqueue(Event::TcpConnectionConfirmed);
+                tcp_connection
+                    .as_ref()
+                    .unwrap()
+                    .set_nonblocking(true)
+                    .unwrap();
             };
             tcp_connection
         }
     }
 
+    fn send_bgp_message_to_remote_peer(&self, bgp_message: BgpMessage) {
+        self.tcp_connection
+            .as_ref()
+            .unwrap()
+            .write(&bgp_message.serialize()[..])
+            .expect("Failed send open message");
+        info!("Send bgp message {:?}", bgp_message);
+    }
+
     fn handle_event(&mut self, event: Event) {
         match self.now_state {
             State::Idle => match event {
             },
             State::Connect => match event {
                 Event::TcpConnectionConfirmed | Event::TcpCrAcked => {
+                    let open_message = BgpOpenMessage::new(
+                        self.config.local_as_number,
+                        self.config.local_ip_address,
+                    );
+                    self.send_bgp_message_to_remote_peer(BgpMessage::Open(open_message));
                     self.now_state = State::OpenSent;
                 }
                 _ => {}
             },
+            State::OpenSent => match event {
+                Event::BgpOpen => {
+                    self.now_state = State::OpenConfirm;
+                }
+                _ => {}
+            },
             _ => {}
         }
     }
     Idle,
     Connect,
     OpenSent,
+    OpenConfirm,
 }
 
-#[derive(PartialEq, Eq, Clone, Copy)]
+#[derive(Debug, PartialEq, Eq, Clone, Copy)]
 pub enum Event {
     ManualStart,
     TcpCrAcked,
     TcpConnectionConfirmed,
+    BgpOpen,
 }
 
 #[cfg(test)]
     use std::thread;
     use std::time;
 
+    fn init() {
+        let _ = env_logger::builder().is_test(true).try_init();
+    }
+
     #[test]
-    fn peer_can_transition_to_connect_start() {
+    fn peer_can_transition_to_connect() {
+        init();
         let config: Config = "64512 127.0.0.1 64513 127.0.0.2 active".parse().unwrap();
         let mut bgp_peer = Peer::new(config);
         bgp_peer.start();
     }
 
     #[test]
-    fn peer_can_transition_to_open_sent_start() {
+    fn peer_can_transition_to_open_sent() {
+        init();
         let _remote_bgp = thread::spawn(|| {
             let remote_config: Config = "64513 127.0.0.2 64512 127.0.0.1 passive".parse().unwrap();
             let mut remote_bgp_peer = Peer::new(remote_config);
 
         assert_eq!(local_bgp_peer.now_state, State::OpenSent);
     }
+
+    #[test]
+    fn peer_can_transition_to_open_confirm() {
+        init();
+        let _remote_bgp = thread::spawn(|| {
+            let remote_config: Config = "64513 127.0.0.2 64512 127.0.0.1 passive".parse().unwrap();
+            let mut remote_bgp_peer = Peer::new(remote_config);
+            remote_bgp_peer.start();
+
+            let max_steps = 50;
+            for _ in 0..max_steps {
+                remote_bgp_peer.next_step();
+                thread::sleep(time::Duration::from_secs_f32(0.1));
+                if remote_bgp_peer.now_state == State::OpenConfirm {
+                    break;
+                };
+            }
+
+            assert_eq!(remote_bgp_peer.now_state, State::OpenConfirm);
+        });
+
+        // 先にPassiveモード側の処理が進むことを保証する。
+        thread::sleep(time::Duration::from_secs_f32(0.5));
+
+        let local_config: Config = "64512 127.0.0.1 64513 127.0.0.2 active".parse().unwrap();
+        let mut local_bgp_peer = Peer::new(local_config);
+
+        local_bgp_peer.start();
+        let max_steps = 50;
+        for _ in 0..max_steps {
+            local_bgp_peer.next_step();
+            thread::sleep(time::Duration::from_secs_f32(0.1));
+            if local_bgp_peer.now_state == State::OpenConfirm {
+                break;
+            };
+        }
+
+        assert_eq!(local_bgp_peer.now_state, State::OpenConfirm);
+    }
 }
----

[source,rust,linenums,title=src/bgp/queue.rs]
----
+use crate::bgp::message::BgpMessage;
+use crate::bgp::peer::Event;
+use std::collections::VecDeque;
+
+pub struct Queue<T>(VecDeque<T>);
+
+impl<T> Queue<T> {
+    pub fn new() -> Self {
+        Queue(VecDeque::new())
+    }
+
+    pub fn enqueue(&mut self, data: T) {
+        self.0.push_front(data);
+    }
+
+    pub fn dequeue(&mut self) -> Option<T> {
+        self.0.pop_back()
+    }
+}
+
+pub type EventQueue = Queue<Event>;
+pub type MessageQueue = Queue<BgpMessage>;
----

[source,rust,linenums,title=src/bgp/timer.rs]
----
+#[derive(Debug)]
+pub struct HoldTime(pub u16);
----

[source,rust,linenums,title=src/lib.rs]
----
+#[macro_use]
+extern crate log;
+
 pub mod bgp;
----



テストを走らせてみましょう。
下記が結果です。無事にテストが通っていることが確認できました。

----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ RUST_LOG=mrbgpdv2=INFO cargo test -- --nocapture --test-threads=1
   Compiling mrbgpdv2first v0.1.0 (/home/mrcsce/programming/rustProjects/mrbgpdv2/mrbgpdv2first)
running 3 tests
test bgp::peer::tests::peer_can_transition_to_connect ... ok
test bgp::peer::tests::peer_can_transition_to_open_confirm ... [2021-05-12T13:42:37Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-12T13:42:37Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-12T13:42:37Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-12T13:42:37Z INFO  mrbgpdv2first::bgp::peer] Recive bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
ok
test bgp::peer::tests::peer_can_transition_to_open_sent ... [2021-05-12T13:42:38Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64512), hold_time: HoldTime(240), bgp_identifier: 127.0.0.1, optional_parameter_length: 0, optional_parameters: [] })
[2021-05-12T13:42:38Z INFO  mrbgpdv2first::bgp::peer] Send bgp message Open(BgpOpenMessage { header: BgpMessageHeader { length: 29, type_: Open }, version: BgpVersion(4), my_autonomous_system_number: AutonomousSystemNumber(64513), hold_time: HoldTime(240), bgp_identifier: 127.0.0.2, optional_parameter_length: 0, optional_parameters: [] })
ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.30s

     Running unittests (target/debug/deps/mrbgpdv2first-229e56fd8674fb31)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests mrbgpdv2first

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
----

現段階の全体のコードを記載します。GitHub上で閲覧したい方は、 https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first[GitHub-現段階の全体のコード]を参照してください。

----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── bgp
│   │   ├── config.rs
│   │   ├── message.rs
│   │   ├── mod.rs
│   │   ├── peer.rs
│   │   ├── queue.rs
│   │   └── timer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title="src/bgp/config.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/config.rs[]
----

[source,rust,linenums,title="src/bgp/message.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/message.rs[]
----


[source,rust,linenums,title="src/bgp/mod.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/mod.rs[]
----


[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/peer.rs[]
----


[source,rust,linenums,title="src/bgp/queue.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/queue.rs[]
----


[source,rust,linenums,title="src/bgp/timer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/bgp/timer.rs[]
----

[source,rust,linenums,title="src/lib.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/lib.rs[]
----

[source,rust,linenums,title="src/main.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/87771a19f2f90e16546a4603a235cb9f02b4313d/mrbgpdv2first/src/main.rs[]
----

==== Establishedに遷移する



=== 1つのピアでUpdate Messageの交換やUpdate Messageの内容に従ってRouting Tableへの書き込みを可能にするところまでの実装

=== main関数の実装
=== 本章で作るものの全体像
[plantuml]
----
@startuml
class Animal {
  run()
}

class Cat extends Animal {
}
@enduml
----


== 複数ピアをハンドリング可能な実装
=== 本章で作るものの全体像

== 他社実装との疎通確認
