:toc:
:source-highlighter: pygments
:prewrap!:


= 作って学ぶルーティングプロトコル〜RustでBGPを実装〜
Miyoshi Ryota (@llp_qlv / mr-csce (miyoshi))

== はじめに
現在執筆中です。

次の本書のGitHubリポジトリや、本書で作成したBGPデーモンのリポジトリにStarをいただけると嬉しいです。
++++
本書のリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=how-to-create-bgp
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
本書で作成したBGPデーモンのリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=mrbgpdv2
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
++++

本書ではルーティングプロトコルの1つであるBGP（特に今回はEBGP4）をRustで実装する本です。
読者に以下の前提知識を求めています。

. ルーティングプロトコルは聞いたことがある。
. スタティックルートとは何か分かる。
. ルーティングテーブルを見て意味が分かる。
. 何らかのプログラミング言語でのプログラミング経験

以下の経験があるとよりわかりやすいかもしれません。

. BGPの運用経験

=== 執筆環境
筆者は以下の環境で作成・動作確認しています。

* Ubuntu 20.04 LTS / Pop!_OS 20.04 LTS
* cargo 1.53.0-nightly (f3e13226d 2021-04-30)
* rustc 1.54.0-nightly (676ee1472 2021-05-06)

おそらくほとんど全てのLinux Distribution、MacOSでも動作するものと考えていますが、確認・テストはしていません。
RustのVersionについても同様にテストしていませんが、
ある程度新しければ動作すると考えています。

== BGPの実装に必要な知識の学習
=== BGPとは
本章は執筆予定です。すでに良い教材が多く存在するため後回しにしています。
本章が執筆されるまでの参考文献として、2つ紹介します。
BGPについて詳しくない方は、どちらかを読み、本章以降に進んでください。
すべての内容を記憶する必要はありません。
なんとなく見ておくと、本章以降の理解が容易になります。

https://www.infraexpert.com/study/study60.html[ネットワークエンジニアとして - BGPの技術]の次の章が参考になります。

* https://www.infraexpert.com/study/bgpz01.html[BGP（ Border Gateway Protocol ）とは]
* https://www.infraexpert.com/study/bgpz02.html[BGP - 4つのメッセージ、6つのステータスと状態遷移]
* https://www.infraexpert.com/study/bgpz03.html[BGP - IBGPとEBGPの違い]
* https://www.infraexpert.com/study/bgpz04.html[BGP - スタブAS、トランジットAS、非トランジットAS]
* https://www.infraexpert.com/study/bgpz05.html[BGP - パスアトリビュート（ パス属性 ）＆ ベストパス選択]
* https://www.infraexpert.com/study/bgpz06.html[BGP - コンフィグ設定 - 基本設定]

http://www5e.biglobe.ne.jp/aji/30min/index.html[30分間ネットワーキング]の次の章が参考になります。

* http://www5e.biglobe.ne.jp/aji/30min/16.html[第16回 BGP4(1) AS]
* http://www5e.biglobe.ne.jp/aji/30min/17.html[第17回 BGP4(2) BGPピア]
* http://www5e.biglobe.ne.jp/aji/30min/18.html[第18回 BGP4(3) IBGPとEBGP]
* http://www5e.biglobe.ne.jp/aji/30min/19.html[第19回 BGP4(4) パスアトリビュート]
* http://www5e.biglobe.ne.jp/aji/30min/20.html[第20回 BGP4(5) ベストパス選択]

=== BGPはイベント駆動ステートマシン
=== イベント駆動ステートマシンとは [[what_is_event_driven_state_machine]]
イベント駆動ステートマシンとは、現在の状態（ステート）と入力（イベント）によって動作が決定するモノのモデルです。

例として、テレビをステートマシンとして表現します。
テレビの状態として、1. 電源ON、2. 電源OFFの2状態が存在し、入力としてa. 電源ボタンの押下、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下の3つが存在するとします。本来のテレビはもっと多数の状態やイベントを持っていますが、ここでは例示のためにシンプルにしています。

テレビの状態が1. 電源OFFのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源ONに遷移します。テレビの状態が1. 電源OFFのときに、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合はテレビの状態は1. 電源OFFのままで何も起こりません。

テレビの状態が2. 電源ONのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源OFFに遷移します。テレビの状態が2. 電源ONのときb. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合は、テレビの状態は2. 電源ONのまま音量が増減します。

このように現在の状態と、入力によって動作が決定するモノとして表現することが可能です。これを図示すると<<example_state_machine_diagram>>になります。

[[example_state_machine_diagram]]
[plantuml,title=テレビのステートマシン図]
----
@startuml

state 電源OFF

state 電源ON

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----

本書ではステートマシン図では表しにくい動作の内容について、<<example_state_machine_diagram_2>>のように付箋をつけることにします。
この図では、状態が電源ONのときに、音量増加ボタンの押下が入力されたときには、状態を電源ONのままにするだけでなく、音量を増加させることを表しています。

[[example_state_machine_diagram_2]]
[plantuml,title=テレビのイベント駆動ステートマシンとしての表現（本書の記法）]
----
@startuml

state 電源OFF

state 電源ON

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
note on link
   音量の増加
end note
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----

=== イベント駆動ステートマシンの例
イベント駆動ステートマシンをどのよう実装すればいいのかという勘所を掴んでもらうために<<what_is_event_driven_state_machine>>の章で例示したテレビをコードにします。
次のようになります。

[[example_of_state_machine_impl]]
[source,rust,linenums,title="イベント駆動ステートマシンの例（テレビ）"]
----
use rand::Rng;
use std::collections::VecDeque;
use std::thread;
use std::time::Duration;

#[derive(Debug)]
enum State {
    PowerOn,
    PowerOff,
}

#[derive(Debug)]
enum Event {
    PushedPowerButton,
    PushedVolumeIncreaseButton,
    PushedVolumeDecreaseButton,
}

struct TV {
    now_state: State,
    event_queue: EventQueue,
    volume: u8,
}

impl TV {
    pub fn new() -> Self {
        let now_state = State::PowerOff;
        let event_queue = EventQueue::new();
        let volume = 10;
        Self {
            now_state,
            event_queue,
            volume,
        }
    }

    pub fn be_pushed_power_button(&mut self) {
        self.event_queue.enqueue(Event::PushedPowerButton);
    }

    pub fn be_pushed_volume_increase_button(&mut self) {
        self.event_queue.enqueue(Event::PushedVolumeIncreaseButton);
    }

    pub fn be_pushed_volume_decrease_button(&mut self) {
        self.event_queue.enqueue(Event::PushedVolumeDecreaseButton);
    }

    pub fn handle_event(&mut self, event: Event) {
        match &self.now_state {
            &State::PowerOn => match event {
                Event::PushedPowerButton => {
                    self.now_state = State::PowerOff;
                }
                Event::PushedVolumeIncreaseButton => {
                    self.volume += 1;
                }
                Event::PushedVolumeDecreaseButton => {
                    self.volume -= 1;
                }
            },
            &State::PowerOff => match event {
                Event::PushedPowerButton => {
                    self.now_state = State::PowerOn;
                }
                _ => (),
            },
        }
    }
}

struct EventQueue(VecDeque<Event>);

impl EventQueue {
    pub fn new() -> Self {
        let d = VecDeque::new();
        EventQueue(d)
    }

    pub fn dequeue(&mut self) -> Option<Event> {
        self.0.pop_front()
    }

    pub fn enqueue(&mut self, event: Event) {
        self.0.push_back(event);
    }
}

fn push_random_button_of_tv(tv: &mut TV) {
    let mut rng = rand::thread_rng();
    match rng.gen_range(0..4) {
        1 => tv.be_pushed_power_button(),
        2 => tv.be_pushed_volume_increase_button(),
        3 => tv.be_pushed_volume_decrease_button(),
        _ => (),
    };
}

fn main() {
    let mut tv = TV::new();
    tv.be_pushed_power_button();
    loop {
        push_random_button_of_tv(&mut tv);
        if let Some(event) = tv.event_queue.dequeue() {
            println!(
                "tv information: {{ now_state={:?}, volume={} }}\ninput_event: {:?}",
                tv.now_state, tv.volume, event
            );
            tv.handle_event(event);
        }
        thread::sleep(Duration::from_secs(2));
    }
}
----

103行目でTVのランダムなボタンを押下し、TVにイベント（入力）を送信しています。送信されたEventはイベントキュー、tv.event_queueにエンキューします。
104でイベントキューに保存されているイベント（入力）を取り出します。
TVの現在の状態（State）はTVのインスタンスに保存されています。
109行目でイベント（入力）を扱います。
49行目〜69行目を見ると分かるように、`tv.handle_event(event)`はeventとtvインスタンスに保存されている現在の状態に応じて、動作し次の状態を決定します。
それはイベント駆動ステートマシン、そのものでした。このようにしてイベント駆動ステートマシンを実装することができました。

次が<<log_of_sample_state_machine>>です。

ログの4行目を見ると、電源OFFの状態であることがわかります。
次にログの5行目を見ると、電源ボタンが押されたことがわかります。
次にログの6行目を見ると、電源ONの状態に遷移したことがわかります。
次にログの7行目を見ると、音量増加ボタンが押されたことがわかります。
次にログの8行目を見ると、電源ON状態のまま、音量が11に増加していることがわかります。

一方でログの16、17、18行目を見ると、電源OFF状態のときに音量増加ボタンが押されても、電源OFF状態のままで音量の変動もないことがわかります。

[[log_of_sample_state_machine]]
[source,html,linenums,title="実行時のログ"]
----
mrcsce@pop-os:~/programming/rustProjects/samplecode$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/samplecode`
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeDecreaseButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOff, volume=10 }
input_event: PushedPowerButton
tv information: { now_state=PowerOn, volume=10 }
input_event: PushedVolumeIncreaseButton
tv information: { now_state=PowerOn, volume=11 }
input_event: PushedVolumeIncreaseButton
^C
mrcsce@pop-os:~/programming/rustProjects/samplecode$
----


これは<<what_is_event_driven_state_machine>>の章で例示した通りの動作です。
例示したイベント駆動ステートマシンを実装できていることが確かめられました。
BGPのステートマシンも前述の<<example_of_state_machine_impl>>に似た方針で実装していきます。

== 1つのピアを実装するまで
=== BGPはどんなイベント駆動ステートマシンなのか
BGPはどのようなイベント駆動ステートマシンとして表すのが良いでしょうか。

実は https://tools.ietf.org/html/rfc4271[RFC4271-A Border Gateway Protocol 4 (BGP-4)]の https://tools.ietf.org/html/rfc4271#section-8[8.  BGP Finite State Machine (FSM)]に、イベント駆動ステートマシンの定義の記載があります。

しかし最初から https://tools.ietf.org/html/rfc4271#section-8[8.  BGP Finite State Machine (FSM)]を参照して、完全なBGPを作成することは大変です。
そのため本書ではBGPを次の段階に分けて開発します。

1. まずは1つのピアがEstablishedに遷移可能
2. 1つのピアでUpdate Messageの交換やUpdate Messageの内容にしたがってRouting Tableへの書き込みが可能
3. 複数のピアを扱うことが可能
4. 細かい完成度を増加

本章のコードは GitHubの https://github.com/Miyoshi-Ryota/mrbgpdv2[本書のリポジトリ]にすべて公開しています。
本書中にすべてのコードを乗せるつもりですが、断片のコードではなくすべてのコードを一気に閲覧したい方はリポジトリを参照してください。
また本章の第一段階「<<first_rev>>」のコードは同リポジトリの https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/main/mrbgpdv2first[同リポジトリのmrbgpdv2first/] に存在します。


=== 1つのピアがEstablishedに遷移するところまでの実装 [[first_rev]]
まずは1つのピアがEstablishedに至るまでの正常系のみのイベント駆動ステートマシンを実装します。

RFCの方針の通り、1つのBGPピアを1つのイベント駆動ステートマシンとして表します。
BGPのイベント駆動ステートマシンの状態もIdle, Connect, OpenConfirm, OpenSent, Establishedの5つ用意します。
この状態は、 https://www.infraexpert.com/study/bgpz02.html[BGP - 4つのメッセージ、6つのステータスと状態遷移] で説明しているBGPの6つの状態のうちActiveを除いたものと対応しています。Activeは非正常系パスでしか遷移しない状態のため、第一段階では除いています。

第一段階のイベントとして次の5個を使用します。イベントの名前と定義はRFCにしたがってしています。

[cols=2*, title=BGPのイベント駆動ステートマシンのイベント]
|===
| イベント名 | 定義
| ManualStart | システムの管理者が手動でピアのコネクションをスタートさせた際のイベント
| Tcp_CR_Acked| TCPコネクションのリクエストを確立させた際のイベント。言い換えれば、システムがTCP SYNを送信し、TCP SYN/ACKを受信し、TCP ACKを送信したときのイベント。
| TcpConnectionConfirmed | TCPコネクションが確立された際のイベント。言い換えれば、対向先からTCP SYNを受け取り、システムがTCP SYN/ACKを送信し、TCP ACKを受信したときのイベント
| BGPOpen | 正常なOpen Messageを受信したときのイベント
| KeepAliveMsg | Keepalive Messageを受信したときのイベント
|===


以下に<<first_impl_bgp>>を図示します。図中の黒丸はステートマシンの初期状態を表しています。図示していない（想定していない）遷移が発生した場合はすべてクラッシュすることにします。例えば、Connect状態で、BGP Open eventが発生した場合はクラッシュすることにします。

[[first_impl_bgp]]
[plantuml,title="第一段階で実装するステートマシン"]
----
@startuml

state Idle
state Connect
state OpenConfirm
state OpenSent
state Established

[*] --> Idle
Idle --> Connect : ManualStart event
note on link
   対向側機器とTCPコネクションを作成を試みる。
end note
Connect --> OpenSent : Tcp_CR_Acked | TcpConnectionConfirmed event
note on link
   対向側機器にBGP OpenMessageを送信する。
end note
OpenSent --> OpenConfirm : BGPOpen event
note on link
    対向機器にBGP Keepalive Messageを送信する。
end note
OpenConfirm --> Established : KeepAliveMsg event

@enduml
----

==== 作業の明確化
ここまででなんとなく作るものが見えてきたでしょうか。本章では、<<first_rev>>をToDoレベルに明確化します。

[title=タスクリスト]
* [ ] プロジェクトを作成する
* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


==== プロジェクトの作成

Rustは以下のコマンドで新しいプロジェクトを作成することが出来ます。
[source]
----
cargo new <プロジェクトの名前>
----

[title=タスクリスト]
* [x] プロジェクトを作成する
* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


==== Connect Stateに遷移する
それでは中身に入っていきましょう。
下記に取り組みます。

* [ ] Connect Stateに遷移する
    - [ ] ManualStart Eventを発生させる

BGPは1つのピアが1つのイベント駆動ステートマシンとして表せます。
ピアに関するソースコードは./src/bgp/peer.rsに書くことにしましょう。

 ./src/bgp/peer.rsを追加するとディレクトリ構造は下記のようになります。

[source]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── bgp
│   │   ├── mod.rs
│   │   └── peer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title="./lib.rs]
----
pub mod bgp;
----

[source,rust,linenums,title="./bgp/mod.rs]
----
pub mod peer;
----

[source,rust,linenums,title="./bgp/peer.rs]
----
// 空ファイルです
----

まずテストを書きましょう。
Connectに遷移するまでの過程は<<bgp_first_test, 次>>のようにしてみましょう。

[[bgp_first_test]]
[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/connect-state-made/mrbgpdv2first/src/bgp/peer.rs[lines=58..69]
----

bgp_peer.start()でピアのコネクションを開始（ManualStartイベントを発火）させ、bgp_peer.next_step()で、そのピアのイベントキューからイベントを1つ取り出しハンドリングするつもりのコードです。

実はConnect Stateに遷移するところまででは、Configは不要です。しかしこの後、すぐに使用するので、この段階で合わせて実装しています。


このテストが通るまでコンパイラのエラーにしたがってコードを追加していくと下記のようになります。

[source,title="ディレクトリ構造"]
----
├── src
│   ├── bgp
│   │   ├── config.rs
│   │   ├── event_queue.rs
│   │   ├── mod.rs
│   │   └── peer.rs
│   ├── lib.rs
│   └── main.rs
----

[source,rust,linenums,title="src/bgp/mod.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/mod.rs[]
----


[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/peer.rs[]
----

[source,rust,linenums,title="src/bgp/event_queue.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/event_queue.rs[]
----

[source,rust,linenums,title="src/bgp/config.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/4028dd5957849b2ed4b3d7432f56667125163f92/mrbgpdv2first/src/bgp/config.rs[]
----


それではテストを実行し、OKになることを確認しましょう。
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cargo test
   Compiling mrbgpdv2first v0.1.0 (/home/mrcsce/programming/rustProjects/mrbgpdv2/mrbgpdv2first)
    Finished test [unoptimized + debuginfo] target(s) in 0.48s
     Running unittests (target/debug/deps/mrbgpdv2first-773462fadd3e9533)

running 1 tests
test bgp::peer::tests::peer_can_transition_to_connect_start ... ok
----

これでまた1つタスクが完了しました。

[title=タスクリスト]
* [x] プロジェクトを作成する
* [x] Connect Stateに遷移する
    - [x] ManualStart Eventを発生させる
* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


==== Connect Stateに遷移する
次に下記に取り組みます。

* [ ] OpenSent Stateに遷移する
    - [ ] TCPコネクションを作成する

まずはテストを書きます。
threadを使用して擬似的にリモート側のコンピュータを表しています。

[source,rust,linenums,title="src/bgp/peer.rs"]
----
include::https://raw.githubusercontent.com/Miyoshi-Ryota/mrbgpdv2/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first/src/bgp/peer.rs[lines=90..91;93..94;105..128]
----

このテストが通れば、上記のタスクは完了したと言えます。
以下のようなコードでテストを通すことが可能です。

<<diff_of_before>>、
https://github.com/Miyoshi-Ryota/mrbgpdv2/tree/f133fc092a43103322ceadb4b40d9d9f28952548/mrbgpdv2first[テストが通る全体のコード]

[[diff_of_before]]
[source,rust,linenums,title="前回のソースコードとの差分"]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ git diff 4028dd5957849b2ed4b3d7432f56667125163f92
diff --git a/mrbgpdv2first/src/bgp/config.rs b/mrbgpdv2first/src/bgp/config.rs
index 9317ad8..979c19c 100644
--- a/mrbgpdv2first/src/bgp/config.rs
+++ b/mrbgpdv2first/src/bgp/config.rs
@@ -2,19 +2,20 @@ use crate::bgp;
 use std::{net::Ipv4Addr, str::FromStr};
 pub struct Config {
     local_as_number: bgp::AutonomousSystemNumber,
-    local_ip_address: Ipv4Addr,
+    pub local_ip_address: Ipv4Addr,
     remote_as_number: bgp::AutonomousSystemNumber,
-    remote_ip_address: Ipv4Addr,
-    mode: Mode,
+    pub remote_ip_address: Ipv4Addr,
+    pub mode: Mode,
 }
 
-enum Mode {
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum Mode {
     Passive,
     Active,
 }
 
 #[derive(Debug)]
-struct ModeParseError;
+pub struct ModeParseError;
 
 impl FromStr for Mode {
     type Err = ModeParseError;
diff --git a/mrbgpdv2first/src/bgp/peer.rs b/mrbgpdv2first/src/bgp/peer.rs
index a0b8121..523979c 100644
--- a/mrbgpdv2first/src/bgp/peer.rs
+++ b/mrbgpdv2first/src/bgp/peer.rs
@@ -1,20 +1,25 @@
 use super::event_queue::EventQueue;
 use crate::bgp::config::Config;
+use crate::bgp::config::Mode;
+use std::net::{TcpListener, TcpStream};
 
 struct Peer {
     config: Config,
     event_queue: EventQueue,
     now_state: State,
+    tcp_connection: Option<TcpStream>,
 }
 
 impl Peer {
     pub fn new(config: Config) -> Self {
         let event_queue = EventQueue::new();
         let now_state = State::Idle;
+        let tcp_connection = None;
         Self {
             config,
             event_queue,
             now_state,
+            tcp_connection,
         }
     }
 
@@ -28,15 +33,42 @@ impl Peer {
         }
     }
 
+    fn create_tcp_connection_to_remote_ip(&mut self) -> Option<TcpStream> {
+        let remote_addr = self.config.remote_ip_address;
+        let bgp_port = 179;
+        if self.config.mode == Mode::Active {
+            let tcp_connection = TcpStream::connect((remote_addr, bgp_port)).ok();
+            if tcp_connection.is_some() {
+                self.event_queue.enqueue(Event::TcpCrAcked);
+            };
+            tcp_connection
+        } else {
+            let tcp_listener = TcpListener::bind((self.config.local_ip_address, bgp_port))
+                .expect("port 179にbind出来ません。");
+            let tcp_connection = tcp_listener.accept().map(|v| v.0).ok();
+            if tcp_connection.is_some() {
+                self.event_queue.enqueue(Event::TcpConnectionConfirmed);
+            };
+            tcp_connection
+        }
+    }
+
     fn handle_event(&mut self, event: Event) {
         match self.now_state {
             State::Idle => match event {
                 Event::ManualStart => {
+                    self.tcp_connection = self.create_tcp_connection_to_remote_ip();
                     self.now_state = State::Connect;
                 }
                 _ => {}
             },
-            _ => (),
+            State::Connect => match event {
+                Event::TcpConnectionConfirmed | Event::TcpCrAcked => {
+                    self.now_state = State::OpenSent;
+                }
+                _ => {}
+            },
+            _ => {}
         }
     }
 }
----

本コードでは76行目〜77行目でバインドしています。
これはroot権限が必要な操作です。
root権限でテストを実行可能にする必要があります。
cargoのコンフィグファイルにrunner = 'sudo -E'と指定することで
root権限でテストを実行してくれます。

[source,title=~/.cargo/config]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cat ~/.cargo/config 

# nightly-x86_64-unknown-linux-gnu
[target.x86_64-unknown-linux-gnu]
runner = 'sudo -E'
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ 
----


テストを走らせてみましょう。
下記が結果です。無事にテストが通っていることが確認できました。
[source, title=テスト結果]
----
mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ cargo test 
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests (target/debug/deps/mrbgpdv2first-773462fadd3e9533)

running 2 tests
test bgp::peer::tests::peer_can_transition_to_connect_start ... ok
test bgp::peer::tests::peer_can_transition_to_open_sent_start ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.50s

     Running unittests (target/debug/deps/mrbgpdv2first-eb97df666ba678c7)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests mrbgpdv2first

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

mrcsce@pop-os:~/programming/rustProjects/mrbgpdv2/mrbgpdv2first$ 
----

これで、またタスクが一つ完了しました。

* [x] プロジェクトを作成する
* [x] Connect Stateに遷移する
    - [x] ManualStart Eventを発生させる
* [x] OpenSent Stateに遷移する
    - [x] TCPコネクションを作成する
* [ ] OpenConfirm Stateに遷移する
    - [ ] BGP Open Messageを送信する
    - [ ] BGP Open Messageを受信する
* [ ] Established Stateに遷移する
    - [ ] BGP Keepalive Messageを送信する
    - [ ] BGP Keepalive Messageを受信する
* [ ] main関数を作成する
* [ ] テストする


=== 1つのピアでUpdate Messageの交換やUpdate Messageの内容に従ってRouting Tableへの書き込みを可能にするところまでの実装

=== main関数の実装
=== 本章で作るものの全体像
[plantuml]
----
@startuml
class Animal {
  run()
}

class Cat extends Animal {
}
@enduml
----


== 複数ピアをハンドリング可能な実装
=== 本章で作るものの全体像

== 他社実装との疎通確認
