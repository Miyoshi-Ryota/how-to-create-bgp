
:toc:
= 作って学ぶルーティングプロトコル〜RustでBGPを実装〜
Miyoshi Ryota (@llp_qlv / mr-csce (miyoshi))

== はじめに
現在執筆中です。

次の本書のGitHubリポジトリや、本書で作成したBGPデーモンのリポジトリにStarをいただけると嬉しいです。
++++
本書のリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=how-to-create-bgp
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
本書で作成したBGPデーモンのリポジトリ：
<iframe src="https://ghbtns.com/github-btn.html?user=Miyoshi-Ryota&repo=mrbgpd
&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
++++

本書ではルーティングプロトコルの1つであるBGP（特に今回はEBGP4）をRustで実装する本です。
読者に以下の前提知識を求めています。

. ルーティングプロトコルは聞いたことがある。
. スタティックルートとは何か分かる。
. ルーティングテーブルを見て意味が分かる。
. 何らかのプログラミング言語でのプログラミング経験

以下の経験があるとよりわかりやすいかもしれません。

. BGPの運用経験

== BGPの実装に必要な知識の学習
=== BGPとは
本章は執筆予定です。すでに良い教材が多く存在するため後回しにしています。
本章が執筆されるまでの参考文献として、2つ紹介します。
BGPについて詳しくない方は、どちらかを読み、本章以降に進んでください。
すべての内容を記憶する必要はありません。
なんとなく見ておくと、本章以降の理解が容易になります。

https://www.infraexpert.com/study/study60.html[ネットワークエンジニアとして - BGPの技術]の次の章が参考になります。

* https://www.infraexpert.com/study/bgpz01.html[BGP（ Border Gateway Protocol ）とは]
* https://www.infraexpert.com/study/bgpz02.html[BGP - 4つのメッセージ、6つのステータスと状態遷移]
* https://www.infraexpert.com/study/bgpz03.html[BGP - IBGPとEBGPの違い]
* https://www.infraexpert.com/study/bgpz04.html[BGP - スタブAS、トランジットAS、非トランジットAS]
* https://www.infraexpert.com/study/bgpz05.html[BGP - パスアトリビュート（ パス属性 ）＆ ベストパス選択]
* https://www.infraexpert.com/study/bgpz06.html[BGP - コンフィグ設定 - 基本設定]

http://www5e.biglobe.ne.jp/aji/30min/index.html[30分間ネットワーキング]の次の章が参考になります。

* http://www5e.biglobe.ne.jp/aji/30min/16.html[第16回 BGP4(1) AS]
* http://www5e.biglobe.ne.jp/aji/30min/17.html[第17回 BGP4(2) BGPピア]
* http://www5e.biglobe.ne.jp/aji/30min/18.html[第18回 BGP4(3) IBGPとEBGP]
* http://www5e.biglobe.ne.jp/aji/30min/19.html[第19回 BGP4(4) パスアトリビュート]
* http://www5e.biglobe.ne.jp/aji/30min/20.html[第20回 BGP4(5) ベストパス選択]

=== BGPはイベント駆動ステートマシン
=== イベント駆動ステートマシンとは
イベント駆動ステートマシンとは、現在の状態（ステート）と入力（イベント）によって動作が決定するモノのモデルです。

例として、テレビをステートマシンとして表現します。
テレビの状態として、1. 電源ON、2. 電源OFFの2状態が存在し、入力としてa. 電源ボタンの押下、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下の3つが存在するとします。本来のテレビはもっと多数の状態やイベントを持っていますが、ここでは例示のためにシンプルにしています。

テレビの状態が1. 電源OFFのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源ONに遷移します。テレビの状態が1. 電源OFFのときに、b. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合はテレビの状態は1. 電源OFFのままで何も起こりません。

テレビの状態が2. 電源ONのときにa. 電源ボタンの押下が発生した場合はテレビの状態が2. 電源OFFに遷移します。テレビの状態が2. 電源ONのときb. 音量増加ボタンの押下、c. 音量減少ボタンの押下が発生した場合は、テレビの状態は2. 電源ONのまま音量が増減します。

このように現在の状態と、入力によって動作が決定するモノとして表現することが可能です。これを図示すると次のようになります。

[plantuml]
----
@startuml

電源OFF --> 電源ON : 電源ボタンの押下
電源OFF --> 電源OFF : 音量増加ボタンの押下
電源OFF --> 電源OFF : 音量減少ボタンの押下
電源ON --> 電源OFF : 電源ボタンの押下
電源ON --> 電源ON : 音量増加ボタンの押下
電源ON --> 電源ON : 音量減少ボタンの押下

@enduml
----



=== ステートマシンの例

== 1つのピアを実装するまで
=== main関数の実装
=== 本章で作るものの全体像
[plantuml]
----
@startuml
class Animal {
  run()
}

class Cat extends Animal {
}
@enduml
----


== 複数ピアをハンドリング可能な実装
=== 本章で作るものの全体像

== 他社実装との疎通確認
